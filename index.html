<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 22: Biomes & Stability</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  
  /* UI LAYERS */
  #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  
  #crosshair {
    position: absolute; top: 50%; left: 50%; width: 16px; height: 16px;
    transform: translate(-50%, -50%);
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQIW2NkQAKrVq36zwjjgzhQwVOnTv3HCOLAcOAFAQA7Ewzpzs+d7wAAAABJRU5ErkJggg==');
    background-size: 100% 100%; image-rendering: pixelated; opacity: 0.8;
  }

  /* STATS */
  #stats-bar {
    position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 80px; width: 300px; justify-content: center;
  }
  .stat-row { display: flex; gap: 2px; }
  .heart, .food { width: 18px; height: 18px; image-rendering: pixelated; }

  /* INVENTORY */
  #hotbar-container {
    position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; border: 2px solid #222;
    display: flex; gap: 4px; pointer-events: auto;
  }
  .slot {
    width: 48px; height: 48px; background: #8b8b8b; 
    border: 3px solid #373737; border-top-color: #fff; border-left-color: #fff;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    position: relative; cursor: pointer;
  }
  .slot.selected { background: #bbb; border-color: white; }
  .slot img { width: 32px; height: 32px; image-rendering: pixelated; }
  .count {
    position: absolute; bottom: 2px; right: 2px; 
    font-size: 14px; color: white; text-shadow: 2px 2px 0 #000; font-weight: bold;
  }

  /* HAND */
  #hand {
    position: fixed; bottom: -30px; right: 20%; width: 220px; height: 220px;
    background-size: contain; background-repeat: no-repeat;
    transform-origin: bottom right; transition: transform 0.1s;
    image-rendering: pixelated;
  }
  .swing { animation: swing 0.15s ease-in-out; }
  @keyframes swing { 50% { transform: rotate(-45deg) translateY(40px); } }

  /* DEATH SCREEN */
  #death-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(100,0,0,0.6); display: none;
    flex-direction: column; align-items: center; justify-content: center;
    color: white; font-size: 40px; font-weight: bold; pointer-events: auto;
    z-index: 100;
  }
  #respawn-btn {
    margin-top: 20px; padding: 10px 30px; font-size: 20px; cursor: pointer;
    background: #444; color: white; border: 2px solid white;
  }
  
  #controls {
    position: fixed; top: 10px; left: 10px; color: white; 
    text-shadow: 1px 1px 0 #000; font-weight: bold; font-size: 14px;
    background: rgba(0,0,0,0.3); padding: 5px;
  }
  
  #biome-debug {
    position: fixed; top: 40px; left: 10px; color: yellow;
    text-shadow: 1px 1px 0 #000; font-weight: bold; font-size: 14px;
  }
</style>
</head>
<body>

<div id="controls">WASD: Move | SHIFT: Sprint | SPACE: Jump | CLICK: Mine/Place</div>
<div id="biome-debug">Biome: Plains</div>

<div id="ui-layer">
  <div id="crosshair"></div>
  <div id="stats-bar">
    <div id="hearts" class="stat-row"></div>
    <div id="hunger" class="stat-row"></div>
  </div>
  <div id="hotbar-container"></div>
  <div id="hand"></div>
</div>

<div id="death-screen">
  YOU DIED!
  <button id="respawn-btn" onclick="respawn()">Respawn</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- CONFIG ---
const CHUNK_SIZE = 16;
const GRAVITY = 30.0;
const JUMP_FORCE = 11.0;
const SPEED_WALK = 4.5;
const SPEED_SPRINT = 7.5;
const PLAYER_HEIGHT = 1.6;
const PHYSICS_TICK = 1/60; // Physics runs exactly 60 times a sec

// --- ASSETS GENERATOR ---
const canvas = document.createElement("canvas");
canvas.width = 16; canvas.height = 16;
const ctx = canvas.getContext("2d");

function makeTex(colors, draw) {
    ctx.clearRect(0,0,16,16);
    for(let i=0; i<256; i++) {
        ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
        ctx.fillRect(i%16, Math.floor(i/16), 1, 1);
    }
    if(draw) draw(ctx);
    const url = canvas.toDataURL();
    const copy = document.createElement("canvas");
    copy.width=16; copy.height=16; copy.getContext("2d").drawImage(canvas,0,0);
    const tex = new THREE.CanvasTexture(copy);
    tex.magFilter = THREE.NearestFilter;
    tex.colorSpace = THREE.SRGBColorSpace;
    return { tex, url };
}

function drawHeart(c, color) { c.fillStyle = color; c.fillRect(2,5,6,6); c.fillRect(8,5,6,6); c.fillRect(5,9,6,5); }
const heartFull = makeTex(["rgba(0,0,0,0)"], c => drawHeart(c, "#ff0000"));
const heartEmpty = makeTex(["rgba(0,0,0,0)"], c => drawHeart(c, "#550000"));
const foodIcon = makeTex(["rgba(0,0,0,0)"], c => { c.fillStyle="#8d6e63"; c.beginPath(); c.arc(8,8,6,0,Math.PI*2); c.fill(); });

// Block Textures
const tGrass = makeTex(["#4caf50", "#388e3c"]);
const tDirt = makeTex(["#795548", "#5d4037"]);
const tSide = makeTex(["#795548", "#5d4037"], c=>{c.fillStyle="#4caf50"; c.fillRect(0,0,16,3);});
const tStone = makeTex(["#9e9e9e", "#757575"]);
const tWood = makeTex(["#5d4037", "#3e2723"], c=>{c.fillStyle="#3e2723"; c.fillRect(4,0,2,16); c.fillRect(10,0,2,16);});
const tLeaves = makeTex(["#2e7d32", "#4caf50"]);
const tSand = makeTex(["#f6d7b0", "#e1bf92"]);
const tCactus = makeTex(["#66bb6a", "#43a047"], c=>{c.fillStyle="#2e7d32";c.fillRect(2,2,2,2);c.fillRect(10,8,2,2);});
const tSnow = makeTex(["#ffffff", "#eeeeee"]);
const tIce = makeTex(["#b3e5fc", "#81d4fa"]);
const tBedrock = makeTex(["#111", "#000"]);
const tPick = makeTex(["rgba(0,0,0,0)"], c=>{c.fillStyle="#555"; c.fillRect(2,2,12,3); c.fillStyle="#6d4c41"; c.fillRect(7,5,2,9);});

// Materials List
const MATS = [
    [new THREE.MeshLambertMaterial({map:tSide.tex}),new THREE.MeshLambertMaterial({map:tSide.tex}),new THREE.MeshLambertMaterial({map:tGrass.tex}),new THREE.MeshLambertMaterial({map:tDirt.tex}),new THREE.MeshLambertMaterial({map:tSide.tex}),new THREE.MeshLambertMaterial({map:tSide.tex})], // 0: Grass
    new THREE.MeshLambertMaterial({map:tStone.tex}), // 1: Stone
    new THREE.MeshLambertMaterial({map:tWood.tex}), // 2: Wood
    new THREE.MeshLambertMaterial({map:tLeaves.tex}), // 3: Leaves
    new THREE.MeshLambertMaterial({map:tDirt.tex}), // 4: Dirt
    new THREE.MeshLambertMaterial({map:tBedrock.tex}), // 5: Bedrock
    new THREE.MeshLambertMaterial({map:tSand.tex}), // 6: Sand
    new THREE.MeshLambertMaterial({map:tCactus.tex}), // 7: Cactus
    new THREE.MeshLambertMaterial({map:tSnow.tex}), // 8: Snow
    new THREE.MeshLambertMaterial({map:tIce.tex}) // 9: Ice
];

// Inventory
const INV = [
    {id:0, count:0, icon:tSide.url}, // Grass
    {id:1, count:0, icon:tStone.url}, // Stone
    {id:2, count:0, icon:tWood.url}, // Wood
    {id:6, count:0, icon:tSand.url}, // Sand
    {id:8, count:0, icon:tSnow.url}, // Snow
    {id:99, count:1, icon:tPick.url} // Pickaxe
];
let selSlot = 5;

// --- THREE.JS ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 10, 40);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xffffff, 0.6);
sun.position.set(50,100,50);
scene.add(sun);

// --- WORLD GEN (BIOMES) ---
const blocks = {};
const chunkSet = new Set();
const boxGeo = new THREE.BoxGeometry(1,1,1);

function spawnBlock(x,y,z,type) {
    const k=`${x},${y},${z}`;
    if(blocks[k]) return;
    const mesh = new THREE.Mesh(boxGeo, MATS[type]);
    mesh.position.set(x,y,z);
    mesh.userData = {type, hp: (type===1||type===5)?60:20, k, origin: new THREE.Vector3(x,y,z)};
    scene.add(mesh);
    blocks[k] = mesh;
}

function getBiome(x, z) {
    const noise = Math.sin(x/60) + Math.cos(z/60); // Large biomes
    if(noise > 0.8) return 'desert';
    if(noise < -0.8) return 'snow';
    return 'plains';
}

function getHeight(x, z) {
    const b = getBiome(x, z);
    if(b === 'desert') return Math.floor(Math.sin(x/25)*3 + Math.cos(z/25)*3 + 2);
    if(b === 'snow') return Math.floor(Math.sin(x/10)*6 + Math.cos(z/10)*6 + 10); // Higher mountains
    return Math.floor(Math.sin(x/15)*4 + Math.cos(z/15)*4); // Plains
}

function genChunk(cx, cz) {
    const k = `${cx},${cz}`;
    if(chunkSet.has(k)) return;
    chunkSet.add(k);
    
    for(let x=cx; x<cx+CHUNK_SIZE; x++) {
        for(let z=cz; z<cz+CHUNK_SIZE; z++) {
            const h = getHeight(x,z);
            const biome = getBiome(x,z);
            
            spawnBlock(x,-16,z,5); // Bedrock

            // Underground
            for(let y=-15; y<h; y++) {
                if(biome === 'desert') spawnBlock(x,y,z,6); // Sand underground
                else spawnBlock(x,y,z, y<h-3 ? 1 : 4); // Stone/Dirt
            }

            // Surface
            let surf = 0; // Grass
            if(biome === 'desert') surf = 6; // Sand
            if(biome === 'snow') surf = 8; // Snow
            spawnBlock(x,h,z,surf);

            // Flora
            if(Math.random()<0.02) {
                if(biome === 'plains') { // Oak Tree
                    for(let i=1;i<5;i++) spawnBlock(x,h+i,z,2);
                    for(let ly=h+3;ly<=h+5;ly++) 
                        for(let lx=x-2;lx<=x+2;lx++) 
                            for(let lz=z-2;lz<=z+2;lz++) 
                                if(Math.abs(lx-x)+Math.abs(lz-z)<3) spawnBlock(lx,ly,lz,3);
                } else if(biome === 'desert') { // Cactus
                     spawnBlock(x,h+1,z,7); spawnBlock(x,h+2,z,7); spawnBlock(x,h+3,z,7);
                } else if(biome === 'snow') { // Pine Tree (simplified)
                    for(let i=1;i<6;i++) spawnBlock(x,h+i,z,2);
                    for(let ly=h+2;ly<=h+5;ly++)
                         for(let lx=x-1;lx<=x+1;lx++)
                             for(let lz=z-1;lz<=z+1;lz++) spawnBlock(lx,ly,lz,3);
                }
            }
        }
    }
}

// --- PHYSICS ENGINE (FIXED TIME STEP) ---
const player = { pos: new THREE.Vector3(0,10,0), vel: new THREE.Vector3(), onGround: false, hp: 20, food: 20 };
const keys = {};
let yaw=0, pitch=0;

function resolveCollision(newPos) {
    const w = 0.3;
    const bx = Math.floor(newPos.x), by = Math.floor(newPos.y), bz = Math.floor(newPos.z);
    
    // Check Blocks around player bounds
    if(blocks[`${bx},${by},${bz}`]) return true; // Feet
    if(blocks[`${bx},${Math.floor(newPos.y + 1.6)},${bz}`]) return true; // Head
    
    // Check corners for wall sliding prevention
    if(blocks[`${Math.floor(newPos.x+w)},${by},${bz}`]) return true;
    if(blocks[`${Math.floor(newPos.x-w)},${by},${bz}`]) return true;
    if(blocks[`${bx},${by},${Math.floor(newPos.z+w)}`]) return true;
    if(blocks[`${bx},${by},${Math.floor(newPos.z-w)}`]) return true;

    return false;
}

function updatePhysics() {
    if(player.hp <= 0) return;
    
    // Input Handling
    const speed = (keys["ShiftLeft"] ? SPEED_SPRINT : SPEED_WALK);
    const moveDir = new THREE.Vector3(0,0,0);
    const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

    if(keys["KeyW"]) moveDir.add(forward);
    if(keys["KeyS"]) moveDir.sub(forward);
    if(keys["KeyA"]) moveDir.sub(right);
    if(keys["KeyD"]) moveDir.add(right);

    if(moveDir.lengthSq() > 0) {
        moveDir.normalize().multiplyScalar(speed * PHYSICS_TICK);
        if(keys["ShiftLeft"]) { player.food -= PHYSICS_TICK * 0.1; updateUI(); }
    }

    // X Movement
    let testPos = player.pos.clone();
    testPos.x += moveDir.x;
    if(!resolveCollision(testPos)) player.pos.x = testPos.x;

    // Z Movement
    testPos = player.pos.clone();
    testPos.z += moveDir.z;
    if(!resolveCollision(testPos)) player.pos.z = testPos.z;

    // Y Movement (Gravity)
    player.vel.y -= GRAVITY * PHYSICS_TICK;
    testPos = player.pos.clone();
    testPos.y += player.vel.y * PHYSICS_TICK;

    if(resolveCollision(testPos)) {
        // Impact Logic
        if(player.vel.y < -15) { // 4 Block Fall Threshold approx
            takeDamage(Math.floor((Math.abs(player.vel.y) - 15) / 2));
        }
        player.vel.y = 0;
        player.onGround = true;
        player.pos.y = Math.round(player.pos.y);
        
        if(keys["Space"]) { 
            player.vel.y = JUMP_FORCE; 
            player.onGround=false; 
            player.food -= 0.2; updateUI(); 
        }
    } else {
        player.pos.y = testPos.y;
        player.onGround = false;
    }
    
    if(player.pos.y < -30) respawn();
}

// --- MAIN LOOP (ACCUMULATOR) ---
let lastTime = performance.now();
let accumulator = 0;
let isMining = false;
let miningTarget = null;
const ray = new THREE.Raycaster();

genChunk(0,0);
updateUI();

function animate(currentTime) {
    requestAnimationFrame(animate);
    
    const frameTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    accumulator += Math.min(frameTime, 0.1); // Cap to prevent spiral of death

    // Run Physics Fixed Amount of times
    while(accumulator >= PHYSICS_TICK) {
        updatePhysics();
        accumulator -= PHYSICS_TICK;
    }

    // Render Sync
    camera.position.copy(player.pos);
    camera.position.y += PLAYER_HEIGHT;
    camera.rotation.set(pitch, yaw, 0);

    // Biome Debug
    const b = getBiome(Math.floor(player.pos.x), Math.floor(player.pos.z));
    document.getElementById("biome-debug").innerText = "Biome: " + b.toUpperCase();
    scene.fog.color.setHex(b==='desert'?0xeeddbb : (b==='snow'?0xddeeff : 0x87ceeb));
    scene.background.setHex(b==='desert'?0xeeddbb : (b==='snow'?0xddeeff : 0x87ceeb));

    // Mining Jitter (Visual only)
    if(isMining) {
        ray.setFromCamera(new THREE.Vector2(0,0), camera);
        const hits = ray.intersectObjects(Object.values(blocks));
        if(hits.length>0 && hits[0].distance < 4.5) {
            miningTarget = hits[0].object;
            if(miningTarget.userData.type!==5) {
                miningTarget.position.set(
                    miningTarget.userData.origin.x + (Math.random()-0.5)*0.1,
                    miningTarget.userData.origin.y + (Math.random()-0.5)*0.1,
                    miningTarget.userData.origin.z + (Math.random()-0.5)*0.1
                );
                miningTarget.userData.hp -= 1;
                if(miningTarget.userData.hp<=0) {
                    const drop = miningTarget.userData.type===0?4:miningTarget.userData.type;
                    const item = INV.find(i=>i.id===drop);
                    if(item){item.count++;updateUI();}
                    scene.remove(miningTarget);
                    delete blocks[miningTarget.userData.k];
                    miningTarget=null;
                }
            }
        }
    } else if(miningTarget) {
        miningTarget.position.copy(miningTarget.userData.origin);
        miningTarget = null;
    }

    // Throttled Chunk Gen
    if(Math.random()<0.1) {
        const px = Math.floor(player.pos.x/16)*16;
        const pz = Math.floor(player.pos.z/16)*16;
        for(let x=px-16; x<=px+16; x+=16) genChunk(x, pz);
        for(let z=pz-16; z<=pz+16; z+=16) genChunk(px, z);
    }

    renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// --- CONTROLS ---
document.addEventListener("mousedown", e=>{
    if(!document.pointerLockElement) { document.body.requestPointerLock(); return; }
    const hand = document.getElementById("hand");
    hand.classList.remove("swing"); void hand.offsetWidth; hand.classList.add("swing");
    if(e.button===0) isMining = true;
    if(e.button===2) placeBlock();
});
document.addEventListener("mouseup", () => isMining = false);
document.addEventListener("keydown", e=>{ keys[e.code]=true; if(e.key>='1'&&e.key<='5'){selSlot=parseInt(e.key)-1; updateUI();} if(e.key==='6'){selSlot=5;updateUI();} });
document.addEventListener("keyup", e=>keys[e.code]=false);
document.addEventListener("mousemove", e=>{
    if(document.pointerLockElement) {
        yaw -= e.movementX*0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch - e.movementY*0.002));
    }
});

function placeBlock() {
    const item = INV[selSlot];
    if(item.id===99 || item.count<=0) return;
    ray.setFromCamera(new THREE.Vector2(0,0), camera);
    const hits = ray.intersectObjects(Object.values(blocks));
    if(hits.length>0 && hits[0].distance < 4.5) {
        const p = hits[0].point.add(hits[0].face.normal.multiplyScalar(0.5)).floor();
        const dx=Math.abs(p.x-player.pos.x), dz=Math.abs(p.z-player.pos.z), dy=p.y-player.pos.y;
        if(dx<0.8 && dz<0.8 && dy>=0 && dy<2) return;
        spawnBlock(p.x, p.y, p.z, item.id);
        item.count--;
        updateUI();
    }
}

function updateUI() {
    const bar = document.getElementById("hotbar-container");
    bar.innerHTML = "";
    INV.forEach((item,i)=>{
        const d = document.createElement("div");
        d.className = `slot ${i===selSlot?'selected':''}`;
        d.innerHTML = `<img src="${item.icon}">` + (item.id!==99?`<span class="count">${Math.floor(item.count)}</span>`:'');
        bar.appendChild(d);
    });
    document.getElementById("hand").style.backgroundImage = `url(${INV[selSlot].icon})`;
    
    const hDiv = document.getElementById("hearts");
    hDiv.innerHTML = "";
    for(let i=0; i<10; i++) hDiv.innerHTML += `<img src="${i*2 < player.hp ? heartFull.url : heartEmpty.url}" class="heart">`;
    const fDiv = document.getElementById("hunger");
    fDiv.innerHTML = "";
    for(let i=0; i<10; i++) fDiv.innerHTML += `<img src="${i*2 < player.food ? foodIcon.url : ''}" class="food">`;
}

function takeDamage(amt) {
    if(amt<=0) return;
    player.hp -= amt;
    updateUI();
    if(player.hp <= 0) { document.getElementById("death-screen").style.display = "flex"; document.exitPointerLock(); }
}

function respawn() {
    player.hp = 20; player.food = 20; player.vel.set(0,0,0);
    player.pos.set(0,20,0);
    document.getElementById("death-screen").style.display = "none";
    document.body.requestPointerLock();
    updateUI();
}

window.onresize = ()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);}
</script>
</body>
</html>
