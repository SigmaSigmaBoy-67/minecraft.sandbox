<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 21: Silent & Straight</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  
  /* UI LAYERS */
  #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  
  #crosshair {
    position: absolute; top: 50%; left: 50%; width: 16px; height: 16px;
    transform: translate(-50%, -50%);
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQIW2NkQAKrVq36zwjjgzhQwVOnTv3HCOLAcOAFAQA7Ewzpzs+d7wAAAABJRU5ErkJggg==');
    background-size: 100% 100%; image-rendering: pixelated; opacity: 0.8;
  }

  /* STATS */
  #stats-bar {
    position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 80px; width: 300px; justify-content: center;
  }
  .stat-row { display: flex; gap: 2px; }
  .heart, .food { width: 18px; height: 18px; image-rendering: pixelated; }

  /* INVENTORY */
  #hotbar-container {
    position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; border: 2px solid #222;
    display: flex; gap: 4px; pointer-events: auto;
  }
  .slot {
    width: 48px; height: 48px; background: #8b8b8b; 
    border: 3px solid #373737; border-top-color: #fff; border-left-color: #fff;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    position: relative; cursor: pointer;
  }
  .slot.selected { background: #bbb; border-color: white; }
  .slot img { width: 32px; height: 32px; image-rendering: pixelated; }
  .count {
    position: absolute; bottom: 2px; right: 2px; 
    font-size: 14px; color: white; text-shadow: 2px 2px 0 #000; font-weight: bold;
  }

  /* HAND */
  #hand {
    position: fixed; bottom: -30px; right: 20%; width: 220px; height: 220px;
    background-size: contain; background-repeat: no-repeat;
    transform-origin: bottom right; transition: transform 0.1s;
    image-rendering: pixelated;
  }
  .swing { animation: swing 0.15s ease-in-out; }
  @keyframes swing { 50% { transform: rotate(-45deg) translateY(40px); } }

  /* DEATH SCREEN */
  #death-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(100,0,0,0.6); display: none;
    flex-direction: column; align-items: center; justify-content: center;
    color: white; font-size: 40px; font-weight: bold; pointer-events: auto;
    z-index: 100;
  }
  #respawn-btn {
    margin-top: 20px; padding: 10px 30px; font-size: 20px; cursor: pointer;
    background: #444; color: white; border: 2px solid white;
  }
  
  #controls {
    position: fixed; top: 10px; left: 10px; color: white; 
    text-shadow: 1px 1px 0 #000; font-weight: bold; font-size: 14px;
    background: rgba(0,0,0,0.3); padding: 5px;
  }
</style>
</head>
<body>

<div id="controls">WASD: Move | SHIFT: Sprint | SPACE: Jump | CLICK: Mine/Place</div>
<div id="ui-layer">
  <div id="crosshair"></div>
  <div id="stats-bar">
    <div id="hearts" class="stat-row"></div>
    <div id="hunger" class="stat-row"></div>
  </div>
  <div id="hotbar-container"></div>
  <div id="hand"></div>
</div>

<div id="death-screen">
  YOU DIED!
  <button id="respawn-btn" onclick="respawn()">Respawn</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- CONFIG ---
const CHUNK_SIZE = 16;
const GRAVITY = 28.0;
const JUMP_FORCE = 9.5;
const SPEED_WALK = 4.5;
const SPEED_SPRINT = 7.0;
const PLAYER_HEIGHT = 1.6;
const FPS_CAP = 60; // STRICT LIMIT TO STOP CHIRPING

// --- ASSETS ---
const canvas = document.createElement("canvas");
canvas.width = 16; canvas.height = 16;
const ctx = canvas.getContext("2d");

function makeTex(colors, draw) {
    ctx.clearRect(0,0,16,16);
    for(let i=0; i<256; i++) {
        ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
        ctx.fillRect(i%16, Math.floor(i/16), 1, 1);
    }
    if(draw) draw(ctx);
    const url = canvas.toDataURL();
    const copy = document.createElement("canvas");
    copy.width=16; copy.height=16; copy.getContext("2d").drawImage(canvas,0,0);
    const tex = new THREE.CanvasTexture(copy);
    tex.magFilter = THREE.NearestFilter;
    tex.colorSpace = THREE.SRGBColorSpace;
    return { tex, url };
}

function drawHeart(c, color) { c.fillStyle = color; c.fillRect(2,5,6,6); c.fillRect(8,5,6,6); c.fillRect(5,9,6,5); }
const heartFull = makeTex(["rgba(0,0,0,0)"], c => drawHeart(c, "#ff0000"));
const heartEmpty = makeTex(["rgba(0,0,0,0)"], c => drawHeart(c, "#550000"));
const foodIcon = makeTex(["rgba(0,0,0,0)"], c => { c.fillStyle="#8d6e63"; c.beginPath(); c.arc(8,8,6,0,Math.PI*2); c.fill(); });

// Blocks
const tGrass = makeTex(["#4caf50", "#388e3c"]);
const tDirt = makeTex(["#795548", "#5d4037"]);
const tSide = makeTex(["#795548", "#5d4037"], c=>{c.fillStyle="#4caf50"; c.fillRect(0,0,16,3);});
const tStone = makeTex(["#9e9e9e", "#757575"]);
const tWood = makeTex(["#5d4037", "#3e2723"], c=>{c.fillStyle="#3e2723"; c.fillRect(4,0,2,16); c.fillRect(10,0,2,16);});
const tLeaves = makeTex(["#2e7d32", "#4caf50"]);
const tBedrock = makeTex(["#111", "#000"]);
const tPick = makeTex(["rgba(0,0,0,0)"], c=>{c.fillStyle="#555"; c.fillRect(2,2,12,3); c.fillStyle="#6d4c41"; c.fillRect(7,5,2,9);});

const MATS = [
    [new THREE.MeshLambertMaterial({map:tSide.tex}),new THREE.MeshLambertMaterial({map:tSide.tex}),new THREE.MeshLambertMaterial({map:tGrass.tex}),new THREE.MeshLambertMaterial({map:tDirt.tex}),new THREE.MeshLambertMaterial({map:tSide.tex}),new THREE.MeshLambertMaterial({map:tSide.tex})],
    new THREE.MeshLambertMaterial({map:tStone.tex}),
    new THREE.MeshLambertMaterial({map:tWood.tex}),
    new THREE.MeshLambertMaterial({map:tLeaves.tex}),
    new THREE.MeshLambertMaterial({map:tDirt.tex}),
    new THREE.MeshLambertMaterial({map:tBedrock.tex})
];

const INV = [
    {id:0, count:0, icon:tSide.url}, {id:1, count:0, icon:tStone.url},
    {id:2, count:0, icon:tWood.url}, {id:3, count:0, icon:tLeaves.url},
    {id:4, count:0, icon:tDirt.url}, {id:99, count:1, icon:tPick.url}
];
let selSlot = 5;

// --- THREE.JS ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 10, 30);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ"; // CRITICAL FOR WALKING STRAIGHT

const renderer = new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xffffff, 0.5);
sun.position.set(50,100,50);
scene.add(sun);

// --- WORLD ---
const blocks = {};
const chunkSet = new Set();
const boxGeo = new THREE.BoxGeometry(1,1,1);

function spawnBlock(x,y,z,type) {
    const k=`${x},${y},${z}`;
    if(blocks[k]) return;
    const mesh = new THREE.Mesh(boxGeo, MATS[type]);
    mesh.position.set(x,y,z);
    mesh.userData = {type, hp:type===1?60:20, k, origin: new THREE.Vector3(x,y,z)};
    scene.add(mesh);
    blocks[k] = mesh;
}

function getH(x,z) { return Math.floor(Math.sin(x/15)*5 + Math.cos(z/15)*5); }

function genChunk(cx, cz) {
    const k = `${cx},${cz}`;
    if(chunkSet.has(k)) return;
    chunkSet.add(k);
    
    for(let x=cx; x<cx+CHUNK_SIZE; x++) {
        for(let z=cz; z<cz+CHUNK_SIZE; z++) {
            const h = getH(x,z);
            spawnBlock(x,-16,z,5); // Bedrock
            for(let y=-15; y<h; y++) spawnBlock(x,y,z, y<h-3?1:4);
            spawnBlock(x,h,z,0);
            if(Math.random()<0.015) { // Tree
                for(let i=1;i<5;i++) spawnBlock(x,h+i,z,2);
                for(let ly=h+3;ly<=h+5;ly++) 
                    for(let lx=x-2;lx<=x+2;lx++) 
                        for(let lz=z-2;lz<=z+2;lz++) 
                            if(Math.abs(lx-x)+Math.abs(lz-z)<3) spawnBlock(lx,ly,lz,3);
            }
        }
    }
}

// --- PLAYER STATE ---
const player = { pos: new THREE.Vector3(0,10,0), vel: new THREE.Vector3(), onGround: false, hp: 20, food: 20 };
const keys = {};
let yaw=0, pitch=0;

function resolveCollision(newPos) {
    const w = 0.3; // Hitbox width
    const bx = Math.floor(newPos.x); 
    const by = Math.floor(newPos.y); 
    const bz = Math.floor(newPos.z);
    
    // Check Feet Level (and slightly below for stability)
    if(blocks[`${bx},${by},${bz}`]) return true;
    
    // Check Head Level
    if(blocks[`${bx},${Math.floor(newPos.y + 1.6)},${bz}`]) return true;

    // Check surrounding width (prevent walking through corners)
    if(blocks[`${Math.floor(newPos.x+w)},${by},${bz}`]) return true;
    if(blocks[`${Math.floor(newPos.x-w)},${by},${bz}`]) return true;
    if(blocks[`${bx},${by},${Math.floor(newPos.z+w)}`]) return true;
    if(blocks[`${bx},${by},${Math.floor(newPos.z-w)}`]) return true;

    return false;
}

// --- MAIN LOOP ---
let lastTime = 0;
let lastChunkCheck = 0;
let isMining = false;
let miningTarget = null;
const ray = new THREE.Raycaster();

genChunk(0,0);
updateUI();

// ANIMATION LOOP WITH HARD FPS CAP
function animate(time) {
    requestAnimationFrame(animate);
    
    // FPS GOVERNOR (Fixes Chirping)
    const ms = time - lastTime;
    if(ms < 1000/FPS_CAP) return; // Wait until next frame slice
    
    const dt = Math.min(ms/1000, 0.1); // Cap delta time for physics safety
    lastTime = time;

    if(player.hp <= 0) return;

    // --- MOVEMENT LOGIC (Fixed Direction) ---
    const speed = (keys["ShiftLeft"] ? SPEED_SPRINT : SPEED_WALK);
    const moveDir = new THREE.Vector3(0,0,0);

    // Get Forward/Right vectors based on YAW ONLY (ignore pitch)
    const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

    if(keys["KeyW"]) moveDir.add(forward);
    if(keys["KeyS"]) moveDir.sub(forward);
    if(keys["KeyA"]) moveDir.sub(right);
    if(keys["KeyD"]) moveDir.add(right);

    if(moveDir.lengthSq() > 0) {
        moveDir.normalize().multiplyScalar(speed * dt);
        if(keys["ShiftLeft"]) { player.food -= dt*0.1; updateUI(); }
    }

    // X Axis Physics
    let testPos = player.pos.clone();
    testPos.x += moveDir.x;
    if(!resolveCollision(testPos)) player.pos.x = testPos.x;

    // Z Axis Physics
    testPos = player.pos.clone();
    testPos.z += moveDir.z;
    if(!resolveCollision(testPos)) player.pos.z = testPos.z;

    // Y Axis / Gravity
    player.vel.y -= GRAVITY * dt;
    testPos = player.pos.clone();
    testPos.y += player.vel.y * dt;

    if(resolveCollision(testPos)) {
        // Landed
        if(player.vel.y < -12) takeDamage(Math.floor(Math.abs(player.vel.y)-10));
        player.vel.y = 0;
        player.onGround = true;
        player.pos.y = Math.round(player.pos.y); // Snap to grid
        
        if(keys["Space"]) { 
            player.vel.y = JUMP_FORCE; 
            player.onGround=false; 
            player.food-=0.2; 
            updateUI(); 
        }
    } else {
        player.pos.y = testPos.y;
        player.onGround = false;
    }

    if(player.pos.y < -30) respawn();

    // CAMERA SYNC
    camera.rotation.set(pitch, yaw, 0);
    camera.position.copy(player.pos);
    camera.position.y += PLAYER_HEIGHT;

    // MINING JITTER
    if(isMining) {
        ray.setFromCamera(new THREE.Vector2(0,0), camera);
        const hits = ray.intersectObjects(Object.values(blocks));
        if(hits.length > 0 && hits[0].distance < 4.5) {
            miningTarget = hits[0].object;
            if(miningTarget.userData.type !== 5) { // No bedrock
                miningTarget.position.x = miningTarget.userData.origin.x + (Math.random()-0.5)*0.1;
                miningTarget.position.y = miningTarget.userData.origin.y + (Math.random()-0.5)*0.1;
                miningTarget.position.z = miningTarget.userData.origin.z + (Math.random()-0.5)*0.1;
                
                miningTarget.userData.hp -= 1;
                if(miningTarget.userData.hp <= 0) {
                    const drop = miningTarget.userData.type === 0 ? 4 : miningTarget.userData.type;
                    const item = INV.find(i=>i.id===drop);
                    if(item) { item.count++; updateUI(); }
                    
                    scene.remove(miningTarget);
                    delete blocks[miningTarget.userData.k];
                    miningTarget = null;
                }
            }
        }
    } else if(miningTarget) {
        miningTarget.position.copy(miningTarget.userData.origin);
        miningTarget = null;
    }

    // THROTTLED WORLD GEN
    if(time - lastChunkCheck > 500) { 
        lastChunkCheck = time;
        const px = Math.floor(player.pos.x/16)*16;
        const pz = Math.floor(player.pos.z/16)*16;
        for(let x=px-16; x<=px+16; x+=16) genChunk(x, pz);
        for(let z=pz-16; z<=pz+16; z+=16) genChunk(px, z);
    }

    renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// --- INPUTS ---
document.addEventListener("mousedown", e=>{
    if(!document.pointerLockElement) { document.body.requestPointerLock(); return; }
    const hand = document.getElementById("hand");
    hand.classList.remove("swing"); void hand.offsetWidth; hand.classList.add("swing");
    if(e.button===0) isMining = true;
    if(e.button===2) placeBlock();
});
document.addEventListener("mouseup", () => isMining = false);

document.addEventListener("keydown", e=>{ keys[e.code]=true; if(e.key>='1'&&e.key<='6'){selSlot=parseInt(e.key)-1; updateUI();} });
document.addEventListener("keyup", e=>keys[e.code]=false);

document.addEventListener("mousemove", e=>{
    if(document.pointerLockElement) {
        yaw -= e.movementX*0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch - e.movementY*0.002));
    }
});

function placeBlock() {
    const item = INV[selSlot];
    if(item.id===99 || item.count<=0) return;
    ray.setFromCamera(new THREE.Vector2(0,0), camera);
    const hits = ray.intersectObjects(Object.values(blocks));
    if(hits.length>0 && hits[0].distance < 4.5) {
        const hit = hits[0];
        const p = hit.point.add(hit.face.normal.multiplyScalar(0.5)).floor();
        const dx = Math.abs(p.x - player.pos.x);
        const dz = Math.abs(p.z - player.pos.z);
        const dy = p.y - player.pos.y;
        if(dx < 0.8 && dz < 0.8 && dy >= 0 && dy < 2) return; 

        spawnBlock(p.x, p.y, p.z, item.id);
        item.count--;
        updateUI();
    }
}

function updateUI() {
    const bar = document.getElementById("hotbar-container");
    bar.innerHTML = "";
    INV.forEach((item,i)=>{
        const d = document.createElement("div");
        d.className = `slot ${i===selSlot?'selected':''}`;
        d.innerHTML = `<img src="${item.icon}">` + (item.id!==99?`<span class="count">${Math.floor(item.count)}</span>`:'');
        bar.appendChild(d);
    });
    document.getElementById("hand").style.backgroundImage = `url(${INV[selSlot].icon})`;
    
    const hDiv = document.getElementById("hearts");
    hDiv.innerHTML = "";
    for(let i=0; i<10; i++) hDiv.innerHTML += `<img src="${i*2 < player.hp ? heartFull.url : heartEmpty.url}" class="heart">`;

    const fDiv = document.getElementById("hunger");
    fDiv.innerHTML = "";
    for(let i=0; i<10; i++) fDiv.innerHTML += `<img src="${i*2 < player.food ? foodIcon.url : ''}" class="food">`;
}

function takeDamage(amt) {
    player.hp -= amt;
    updateUI();
    if(player.hp <= 0) {
        document.getElementById("death-screen").style.display = "flex";
        document.exitPointerLock();
    }
}

function respawn() {
    player.hp = 20; player.food = 20; player.vel.set(0,0,0);
    player.pos.set(0,10,0);
    document.getElementById("death-screen").style.display = "none";
    document.body.requestPointerLock();
    updateUI();
}

window.onresize = ()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);}
</script>
</body>
</html>
