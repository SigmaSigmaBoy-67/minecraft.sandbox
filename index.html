<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 4: Ores & Icons</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  
  #crosshair {
    position: fixed; top: 50%; left: 50%;
    width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px;
    border: 2px solid white; box-sizing: border-box;
    pointer-events: none; z-index: 10;
  }

  #ui {
    position: fixed; bottom: 10px; left: 50%;
    transform: translateX(-50%);
    text-align: center; pointer-events: none;
  }

  #fly-mode {
    position: fixed; top: 10px; left: 10px;
    color: yellow; font-weight: bold; font-size: 18px;
    text-shadow: 2px 2px 0 #000; display: none;
  }

  #hotbar {
    display: flex; gap: 4px; justify-content: center; margin-top: 6px;
    background: rgba(0,0,0,0.2); padding: 5px; border-radius: 5px;
  }
  
  .slot {
    width: 44px; height: 44px; background: #8b8b8b; 
    border: 3px solid #373737;
    border-top: 3px solid #FFF; border-left: 3px solid #FFF; /* 3D bevel effect */
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    position: relative;
  }
  .slot.selected { background: #bbb; border-color: white; }
  
  /* The Icon Image */
  .slot-icon {
    width: 32px; height: 32px;
    image-rendering: pixelated;
  }
  
  .count {
    position: absolute; bottom: 2px; right: 2px;
    font-size: 14px; color: white; text-shadow: 2px 2px 0 #000;
  }
  .key-bind {
    position: absolute; top: 2px; left: 2px; font-size: 10px; color: #444; font-weight: bold;
  }
</style>
</head>
<body>

<div id="crosshair"></div>
<div id="fly-mode">CREATIVE MODE (FLYING)</div>

<div id="ui">
  <div id="hotbar">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- PHYSICS CONFIG ---
const SPEED_WALK = 0.14;   
const SPEED_SPRINT = 0.24; 
const SPEED_FLY = 0.40;    
const JUMP_FORCE = 0.27;   
const GRAVITY = 0.022;     

// --- SCENE ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 10, 30); // Slightly further fog

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 10);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

// --- TEXTURE PAINTER ---
// This system generates textures and converts them to Images for the UI

const textureCanvas = document.createElement("canvas");
textureCanvas.width = 16; textureCanvas.height = 16;
const ctx = textureCanvas.getContext("2d");

function createTexture(drawFn) {
  // clear
  ctx.clearRect(0,0,16,16);
  // draw
  drawFn(ctx);
  // Create 3D texture
  const tex = new THREE.CanvasTexture(textureCanvas);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestFilter;
  tex.colorSpace = THREE.SRGBColorSpace;
  // Create 2D UI Image URL (Snapshot)
  const dataUrl = textureCanvas.toDataURL();
  
  // Clone canvas for unique texture reference to avoid overwrite issues
  const copy = document.createElement("canvas");
  copy.width=16; copy.height=16;
  copy.getContext("2d").drawImage(textureCanvas,0,0);
  const distinctTex = new THREE.CanvasTexture(copy);
  distinctTex.magFilter = THREE.NearestFilter;
  distinctTex.colorSpace = THREE.SRGBColorSpace;

  return { tex: distinctTex, icon: dataUrl };
}

// Helper: Fill with noise
function fillNoise(ctx, colors) {
  for(let y=0; y<16; y++) {
    for(let x=0; x<16; x++) {
      ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
      ctx.fillRect(x,y,1,1);
    }
  }
}

// Helper: Draw Tool Pixel Art
function drawPixels(ctx, map, palette) {
  for(let y=0; y<16; y++) {
    for(let x=0; x<16; x++) {
      const char = map[y][x];
      if (char !== " ") {
        ctx.fillStyle = palette[char];
        ctx.fillRect(x,y,1,1);
      }
    }
  }
}

// --- DEFINE BLOCKS & ICONS ---

// 1. GRASS
const tGrassTop = createTexture(c => fillNoise(c, ["#4caf50", "#388e3c"]));
const tGrassSide = createTexture(c => {
  fillNoise(c, ["#795548", "#5d4037"]); // dirt
  c.fillStyle = "#4caf50"; c.fillRect(0,0,16,4); // grass top strip
});
const tDirt = createTexture(c => fillNoise(c, ["#795548", "#5d4037"]));

// 2. STONE
const tStone = createTexture(c => fillNoise(c, ["#9e9e9e", "#757575", "#616161"]));

// 3. WOOD
const tWood = createTexture(c => {
  fillNoise(c, ["#5d4037", "#4e342e"]);
  c.fillStyle = "#3e2723"; // Bark lines
  c.fillRect(4,0,2,16); c.fillRect(10,0,2,16);
});

// 4. LEAVES
const tLeaves = createTexture(c => fillNoise(c, ["#2e7d32", "#1b5e20", "#4caf50"]));

// 5. IRON ORE
const tIron = createTexture(c => {
  fillNoise(c, ["#9e9e9e", "#757575"]); // Stone base
  // Add ore specks
  c.fillStyle = "#d7ccc8"; 
  for(let i=0; i<8; i++) c.fillRect(Math.random()*14+1, Math.random()*14+1, 2, 2);
});

// 6. DIAMOND ORE
const tDiamond = createTexture(c => {
  fillNoise(c, ["#9e9e9e", "#757575"]); // Stone base
  c.fillStyle = "#00bcd4"; // Cyan
  for(let i=0; i<6; i++) c.fillRect(Math.random()*14+1, Math.random()*14+1, 2, 2);
});

// 7. BEDROCK
const tBedrock = createTexture(c => fillNoise(c, ["#000", "#222", "#111"]));

// --- TOOLS (Pixel Art Maps) ---
const pickMap = [
  "   BBBB         ", "   B  B         ", "   B  B         ", "    SS          ",
  "    SS          ", "    SS          ", "    SS          ", "    SS          ",
  "    SS          ", "    SS          ", "    SS          ", "    SS          ",
  "    SS          ", "    SS          ", "    SS          ", "    SS          "
];
const axeMap = [
  "   BB           ", "  BBBB          ", "  BBBB          ", "   BSS          ",
  "    SS          ", "    SS          ", "    SS          ", "    SS          ",
  "    SS          ", "    SS          ", "    SS          ", "    SS          ",
  "    SS          ", "    SS          ", "    SS          ", "    SS          "
];
const shovelMap = [
  "    B           ", "   BBB          ", "   BBB          ", "    S           ",
  "    S           ", "    S           ", "    S           ", "    S           ",
  "    S           ", "    S           ", "    S           ", "    S           ",
  "    S           ", "    S           ", "    S           ", "    S           "
];

// Generate Tool Icons
const tPickaxe = createTexture(c => drawPixels(c, pickMap, {B:"#555", S:"#8d6e63"}));
const tAxe = createTexture(c => drawPixels(c, axeMap, {B:"#555", S:"#8d6e63"}));
const tShovel = createTexture(c => drawPixels(c, shovelMap, {B:"#555", S:"#8d6e63"}));


// --- INVENTORY DEFINITION ---
// type: 0=Block, 1=Tool
// id: Block ID or Tool logic
const INV_DATA = [
  { name: "Grass",   type: 0, blockId: 0, icon: tGrassSide.icon },
  { name: "Stone",   type: 0, blockId: 1, icon: tStone.icon },
  { name: "Wood",    type: 0, blockId: 2, icon: tWood.icon },
  { name: "Leaves",  type: 0, blockId: 3, icon: tLeaves.icon },
  { name: "Iron",    type: 0, blockId: 5, icon: tIron.icon },    // New
  { name: "Diamond", type: 0, blockId: 6, icon: tDiamond.icon }, // New
  { name: "Pickaxe", type: 1, toolId: "pick", icon: tPickaxe.icon },
  { name: "Axe",     type: 1, toolId: "axe", icon: tAxe.icon },
  { name: "Shovel",  type: 1, toolId: "shovel", icon: tShovel.icon },
];

// Current counts (start with tools, 0 blocks)
const inventoryCounts = [0, 0, 0, 0, 0, 0, 1, 1, 1]; 
let selectedSlot = 0;

// --- BUILD HOTBAR ---
const hotbarEl = document.getElementById("hotbar");
INV_DATA.forEach((item, i) => {
  const div = document.createElement("div");
  div.className = "slot";
  if(i===0) div.classList.add("selected");
  div.id = `slot-${i}`;
  div.innerHTML = `
    <span class="key-bind">${i+1}</span>
    <img src="${item.icon}" class="slot-icon">
    ${item.type === 0 ? `<span class="count">0</span>` : ''}
  `;
  hotbarEl.appendChild(div);
});

// --- MATERIALS ARRAY ---
// 0:Grass, 1:Stone, 2:Wood, 3:Leaves, 4:Bedrock, 5:Iron, 6:Diamond
const materials = [
  // 0
  [ new THREE.MeshLambertMaterial({ map: tGrassSide.tex }), new THREE.MeshLambertMaterial({ map: tGrassSide.tex }), new THREE.MeshLambertMaterial({ map: tGrassTop.tex }), new THREE.MeshLambertMaterial({ map: tDirt.tex }), new THREE.MeshLambertMaterial({ map: tGrassSide.tex }), new THREE.MeshLambertMaterial({ map: tGrassSide.tex }) ],
  // 1
  new THREE.MeshLambertMaterial({ map: tStone.tex }),
  // 2
  new THREE.MeshLambertMaterial({ map: tWood.tex }),
  // 3
  new THREE.MeshLambertMaterial({ map: tLeaves.tex }),
  // 4
  new THREE.MeshLambertMaterial({ map: tBedrock.tex }),
  // 5 (Iron)
  new THREE.MeshLambertMaterial({ map: tIron.tex }),
  // 6 (Diamond)
  new THREE.MeshLambertMaterial({ map: tDiamond.tex })
];

// HP Values
const BLOCK_HP = { 0: 2, 1: 3, 2: 3, 3: 1, 4: 99999, 5: 5, 6: 8 }; // Diamond is hard!

// --- GAME STATE ---
const keys = {};
let velocityY = 0;
let onGround = false;
let sprint = false;
let flying = false;
let yaw = 0; let pitch = 0;

const blocks = [];
const droppedItems = [];
const boxGeo = new THREE.BoxGeometry(1,1,1);

// --- WORLD GENERATION ---
function createBlock(x, y, z, type) {
  const mat = materials[type];
  let finalMat = Array.isArray(mat) ? mat.map(m=>m.clone()) : mat.clone();
  
  const mesh = new THREE.Mesh(boxGeo, finalMat);
  mesh.position.set(x, y, z);
  mesh.userData = { type: type, hp: BLOCK_HP[type] || 1 };
  scene.add(mesh);
  blocks.push(mesh);
  return mesh;
}

function createTree(x, z) {
  const h = 4 + Math.floor(Math.random()*2);
  for(let y=1; y<=h; y++) createBlock(x,y,z, 2);
  for(let lx=x-2; lx<=x+2; lx++){
    for(let lz=z-2; lz<=z+2; lz++){
       if(lx!==x || lz!==z) createBlock(lx, h, lz, 3);
       if((lx!==x || lz!==z) && Math.random()>0.5) createBlock(lx, h+1, lz, 3);
    }
  }
  createBlock(x, h+2, z, 3);
}

const worldSize = 12;
const depth = 16; // Deeper world!

for (let x = -worldSize; x < worldSize; x++) {
  for (let z = -worldSize; z < worldSize; z++) {
    createBlock(x, 0, z, 0); // Top Grass
    
    // Dirt layer
    createBlock(x, -1, z, 1); 

    // Deep Stone/Ore Generation
    for(let y = -2; y > -depth; y--) {
      const rng = Math.random();
      let type = 1; // Default stone
      
      // Ore Logic
      if (y < -4) {
        if (rng < 0.008) type = 6; // Diamond (Rare, < 1%)
        else if (rng < 0.08) type = 5; // Iron (~8%)
      }
      createBlock(x, y, z, type);
    }
    
    // Bedrock Floor
    createBlock(x, -depth, z, 4); 

    // Trees
    if (Math.random() < 0.02 && (Math.abs(x)>2 || Math.abs(z)>2)) createTree(x,z);
  }
}

// --- LIGHTS ---
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 0.7);
sun.position.set(20, 50, 20);
scene.add(sun);

// --- INPUTS ---
document.addEventListener("keydown", e => {
  keys[e.code] = true;
  if(e.code === "ShiftLeft") sprint = true;
  if(e.code === "KeyF") {
    flying = !flying;
    velocityY = 0;
    document.getElementById("fly-mode").style.display = flying ? "block" : "none";
  }
  if(e.code === "Space" && onGround && !flying) {
    velocityY = JUMP_FORCE; onGround = false;
  }
  // Hotbar 1-9
  if(e.key >= "1" && e.key <= "9") {
    const idx = parseInt(e.key)-1;
    if(idx < INV_DATA.length) {
      selectedSlot = idx;
      updateUI();
    }
  }
});

document.addEventListener("keyup", e => {
  keys[e.code] = false;
  if(e.code === "ShiftLeft") sprint = false;
});

document.body.addEventListener("click", () => document.body.requestPointerLock());
window.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === document.body) {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-1.5, Math.min(1.5, pitch));
  }
});

// --- INTERACTION ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(0,0);

function flashBlock(b) {
  const ms = Array.isArray(b.material) ? b.material : [b.material];
  ms.forEach(m => m.emissive.setHex(0x550000));
  setTimeout(()=> ms.forEach(m => m.emissive.setHex(0)), 100);
}

document.addEventListener("mousedown", e => {
  if(document.pointerLockElement !== document.body) return;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(blocks);
  if(hits.length===0) return;
  const hit = hits[0];
  const b = hit.object;
  const type = b.userData.type;

  // MINE
  if(e.button === 0) {
    let damage = 1;
    
    // Creative/Flying Instant Break
    if (flying) {
      damage = 999999; 
    } else {
      // Survival Tool Logic
      const item = INV_DATA[selectedSlot];
      if (item.type === 1) { // If tool
        if (item.toolId==="pick" && (type===1||type===5||type===6)) damage = 10;
        if (item.toolId==="axe" && (type===2)) damage = 10;
        if (item.toolId==="shovel" && (type===0)) damage = 10;
      }
      if (type === 4) return; // Cannot break bedrock in survival
    }

    b.userData.hp -= damage;
    flashBlock(b);

    if (b.userData.hp <= 0) {
      // Drop item
      if (type !== 4) { // Bedrock doesn't drop
        const drop = new THREE.Mesh(boxGeo, b.material);
        drop.scale.set(0.3,0.3,0.3);
        drop.position.copy(b.position);
        drop.userData = { isDrop:true, velY: 0.2, type: type };
        droppedItems.push(drop);
        scene.add(drop);
      }
      scene.remove(b);
      blocks.splice(blocks.indexOf(b), 1);
    }
  }
  // PLACE
  else if (e.button === 2) {
    const item = INV_DATA[selectedSlot];
    if (item.type === 0 && (flying || inventoryCounts[selectedSlot] > 0)) {
      const pos = b.position.clone().add(hit.face.normal);
      // collision check
      const pPos = camera.position.clone(); pPos.y -= 1.6;
      if(pos.distanceTo(pPos) < 1.0) return;

      createBlock(pos.x, pos.y, pos.z, item.blockId);
      if(!flying) {
        inventoryCounts[selectedSlot]--;
        updateUI();
      }
    }
  }
});

function updateUI() {
  document.querySelectorAll(".slot").forEach((el, i) => {
    if(i===selectedSlot) el.classList.add("selected");
    else el.classList.remove("selected");
    
    const countEl = el.querySelector(".count");
    if(countEl) countEl.innerText = inventoryCounts[i];
  });
}

// --- ANIMATION ---
function animate() {
  requestAnimationFrame(animate);
  
  camera.rotation.y = yaw;
  camera.rotation.x = pitch;
  
  const speed = flying ? SPEED_FLY : (sprint ? SPEED_SPRINT : SPEED_WALK);
  const dir = new THREE.Vector3();
  const fwd = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
  const rgt = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)).normalize();
  
  if(keys["KeyW"]) dir.add(fwd);
  if(keys["KeyS"]) dir.sub(fwd);
  if(keys["KeyA"]) dir.sub(rgt);
  if(keys["KeyD"]) dir.add(rgt);
  
  if(flying) {
    if(keys["Space"]) camera.position.y += speed;
    if(keys["ShiftLeft"]) camera.position.y -= speed;
  }
  
  if(dir.length() > 0) {
    dir.normalize();
    const rayOrigin = camera.position.clone(); rayOrigin.y-=1;
    const moveRay = new THREE.Raycaster(rayOrigin, dir, 0, 0.5);
    if(moveRay.intersectObjects(blocks).length===0) camera.position.addScaledVector(dir, speed);
  }
  
  // Gravity
  if(!flying) {
    if(!onGround) velocityY -= GRAVITY;
    camera.position.y += velocityY;
    
    const downRay = new THREE.Raycaster(camera.position, new THREE.Vector3(0,-1,0), 0, 1.8);
    const hits = downRay.intersectObjects(blocks);
    if(hits.length>0 && velocityY<=0) {
      camera.position.y = hits[0].point.y + 1.8;
      velocityY=0; onGround=true;
    } else {
      onGround=false;
    }
  }
  
  if(camera.position.y < -30 && !flying) { camera.position.set(0,10,0); velocityY=0; }

  // Drops
  for(let i=droppedItems.length-1; i>=0; i--) {
    const d = droppedItems[i];
    d.userData.velY -= GRAVITY;
    d.position.y += d.userData.velY;
    
    // Simple floor collision
    if(d.position.y < Math.floor(d.position.y)+0.5) {
       d.position.y = Math.floor(d.position.y)+0.5;
       d.userData.velY = 0;
    }
    d.rotation.y += 0.05;
    
    if(d.position.distanceTo(camera.position) < 1.5) {
      // Find which slot matches this block type
      const type = d.userData.type;
      // map block type to inventory slot index
      // Grass=0, Stone=1, Wood=2, Leaves=3, Iron=4, Diamond=5
      let slotIdx = -1;
      INV_DATA.forEach((item, idx) => { if(item.blockId === type) slotIdx = idx; });
      
      if(slotIdx > -1) {
        inventoryCounts[slotIdx]++;
        updateUI();
      }
      scene.remove(d);
      droppedItems.splice(i,1);
    }
  }

  renderer.render(scene, camera);
}

updateUI();
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
