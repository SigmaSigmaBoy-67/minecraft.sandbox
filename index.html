<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 8.1: Solid Ground</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  #game-ui { visibility: hidden; }
  #crosshair {
    position: fixed; top: 50%; left: 50%; width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px; border: 2px solid white; pointer-events: none; z-index: 10;
  }
  #ui-container { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
  #loading-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #222;
    z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  #loading-text { color: white; font-size: 20px; margin-bottom: 20px; }
  #progress-bar-box { width: 300px; height: 20px; border: 2px solid white; }
  #progress-bar { width: 0%; height: 100%; background: #4caf50; }
  #hotbar { display: flex; gap: 4px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; }
  .slot {
    width: 44px; height: 44px; background: #8b8b8b; border: 3px solid #373737;
    display: flex; align-items: center; justify-content: center; position: relative;
  }
  .slot.selected { border-color: white; background: #bbb; }
  .slot-icon { width: 32px; height: 32px; image-rendering: pixelated; }
  .count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; color: white; text-shadow: 1px 1px 0 #000; }
</style>
</head>
<body>

<div id="loading-screen">
  <div id="loading-text">BUILDING TERRAIN...</div>
  <div id="progress-bar-box"><div id="progress-bar"></div></div>
</div>

<div id="game-ui">
  <div id="crosshair"></div>
  <div id="ui-container"><div id="hotbar"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- SETTINGS ---
const RENDER_DIST = 8;
const SPEED_WALK = 0.07; // Much slower
const SPEED_SPRINT = 0.12;
const GRAVITY = 0.015;
const JUMP = 0.2;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 20, 50);

const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xffffff, 0.6);
sun.position.set(10, 20, 10);
scene.add(sun);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- TEXTURES ---
const canvas = document.createElement("canvas");
canvas.width = 16; canvas.height = 16;
const ctx = canvas.getContext("2d");

function makeTex(colors, overlayFn) {
    for(let i=0; i<256; i++) {
        ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
        ctx.fillRect(i%16, Math.floor(i/16), 1, 1);
    }
    if(overlayFn) overlayFn(ctx);
    const t = new THREE.CanvasTexture(canvas);
    t.magFilter = THREE.NearestFilter;
    const url = canvas.toDataURL();
    const copy = document.createElement("canvas");
    copy.width=16; copy.height=16; copy.getContext("2d").drawImage(canvas,0,0);
    const t2 = new THREE.CanvasTexture(copy); t2.magFilter = THREE.NearestFilter;
    return { tex: t2, icon: url };
}

const grassTop = makeTex(["#4caf50", "#388e3c"]);
const grassSide = makeTex(["#795548", "#5d4037"], c => { c.fillStyle="#4caf50"; c.fillRect(0,0,16,4); });
const dirt = makeTex(["#795548", "#5d4037"]);
const stone = makeTex(["#9e9e9e", "#757575"]);
const wood = makeTex(["#5d4037"], c => { c.fillStyle="#3e2723"; c.fillRect(4,0,2,16); });

const materials = [
    [new THREE.MeshLambertMaterial({map:grassSide.tex}), new THREE.MeshLambertMaterial({map:grassSide.tex}), new THREE.MeshLambertMaterial({map:grassTop.tex}), new THREE.MeshLambertMaterial({map:dirt.tex}), new THREE.MeshLambertMaterial({map:grassSide.tex}), new THREE.MeshLambertMaterial({map:grassSide.tex})],
    new THREE.MeshLambertMaterial({map:stone.tex}),
    new THREE.MeshLambertMaterial({map:wood.tex})
];

const INV = [
    { name: "Grass", id: 0, icon: grassSide.icon },
    { name: "Stone", id: 1, icon: stone.icon },
    { name: "Wood", id: 2, icon: wood.icon }
];
let counts = [0, 0, 0];
let selected = 0;

// --- GENERATION ---
const blocks = {};
const boxGeo = new THREE.BoxGeometry(1,1,1);

function getHeight(x, z) {
    return Math.floor(Math.sin(x/8)*3 + Math.cos(z/8)*3);
}

function spawn(x, y, z, type) {
    const m = Array.isArray(materials[type]) ? materials[type] : materials[type];
    const mesh = new THREE.Mesh(boxGeo, m);
    mesh.position.set(x, y, z);
    mesh.userData = { type, key: `${x},${y},${z}`, hp: (type === 1 ? 60 : 20) };
    scene.add(mesh);
    blocks[`${x},${y},${z}`] = mesh;
}

// --- LOADING ---
let gX = -RENDER_DIST, gZ = -RENDER_DIST;
function loadBatch() {
    for(let i=0; i<40; i++) {
        if(gX > RENDER_DIST) { start(); return; }
        const h = getHeight(gX, gZ);
        for(let y=-3; y<=h; y++) spawn(gX, y, gZ, y===h ? 0 : (y > h-2 ? 0 : 1));
        gZ++; if(gZ > RENDER_DIST) { gZ = -RENDER_DIST; gX++; }
    }
    const p = Math.floor(((gX + RENDER_DIST) / (RENDER_DIST*2)) * 100);
    document.getElementById("progress-bar").style.width = p + "%";
    requestAnimationFrame(loadBatch);
}

// --- MINING LOGIC ---
let isMining = false;
let miningProgress = 0;
let miningTarget = null;

function start() {
    document.getElementById("loading-screen").style.display = "none";
    document.getElementById("game-ui").style.visibility = "visible";
    camera.position.set(0, 10, 0); // Start high
    animate();
}

// --- INPUTS ---
const keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);
document.body.onclick = () => document.body.requestPointerLock();
document.onmousedown = (e) => { if(e.button === 0) isMining = true; if(e.button === 2) placeBlock(); };
document.onmouseup = () => { isMining = false; miningProgress = 0; if(miningTarget) miningTarget.position.x = Math.round(miningTarget.position.x); };

let yaw = 0, pitch = 0;
document.onmousemove = e => {
    if(document.pointerLockElement) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
    }
};

const ray = new THREE.Raycaster();
function placeBlock() {
    ray.setFromCamera(new THREE.Vector2(), camera);
    const hits = ray.intersectObjects(Object.values(blocks));
    if(hits.length > 0 && hits[0].distance < 4) {
        const pos = hits[0].object.position.clone().add(hits[0].face.normal);
        if(!blocks[`${pos.x},${pos.y},${pos.z}`]) spawn(pos.x, pos.y, pos.z, INV[selected].id);
    }
}

let velY = 0, onGround = false;
function animate() {
    requestAnimationFrame(animate);

    // Movement
    camera.rotation.set(pitch, yaw, 0);
    const dir = new THREE.Vector3();
    if(keys["KeyW"]) dir.z -= 1; if(keys["KeyS"]) dir.z += 1;
    if(keys["KeyA"]) dir.x -= 1; if(keys["KeyD"]) dir.x += 1;
    dir.applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize().multiplyScalar(SPEED_WALK);
    camera.position.add(dir);

    // Gravity & Collision
    velY -= GRAVITY;
    camera.position.y += velY;
    onGround = false;
    const pX = Math.round(camera.position.x), pY = Math.floor(camera.position.y - 1.6), pZ = Math.round(camera.position.z);
    if(blocks[`${pX},${pY},${pZ}`]) {
        camera.position.y = pY + 2.6;
        velY = 0; onGround = true;
    }
    if(keys["Space"] && onGround) velY = JUMP;
    if(camera.position.y < -10) camera.position.y = 10; // Void rescue

    // Mining Loop
    if(isMining) {
        ray.setFromCamera(new THREE.Vector2(), camera);
        const hits = ray.intersectObjects(Object.values(blocks));
        if(hits.length > 0 && hits[0].distance < 4) {
            const b = hits[0].object;
            miningTarget = b;
            miningProgress++;
            b.position.x += Math.sin(miningProgress) * 0.02; // Shake effect
            if(miningProgress >= b.userData.hp) {
                scene.remove(b);
                delete blocks[b.userData.key];
                miningProgress = 0;
            }
        }
    }

    renderer.render(scene, camera);
}

// Start
const hot = document.getElementById("hotbar");
INV.forEach((item, i) => {
    hot.innerHTML += `<div class="slot ${i==0?'selected':''}" id="s${i}"><img src="${item.icon}" class="slot-icon"></div>`;
});

loadBatch();
</script>
</body>
</html>
