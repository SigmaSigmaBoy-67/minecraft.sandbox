<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 11: Solid Walls & Physics</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  #game-ui { visibility: hidden; }
  #crosshair {
    position: fixed; top: 50%; left: 50%; width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px; border: 2px solid white; pointer-events: none; z-index: 10;
  }
  #ui-container { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
  #loading-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #222;
    z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  #loading-text { color: white; font-size: 20px; margin-bottom: 20px; font-weight: bold; }
  #progress-bar-box { width: 300px; height: 30px; border: 3px solid white; padding: 2px; }
  #progress-bar { width: 0%; height: 100%; background: #4caf50; transition: width 0.1s; }
  #hotbar { display: flex; gap: 4px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; }
  .slot {
    width: 44px; height: 44px; background: #8b8b8b; border: 3px solid #373737;
    display: flex; align-items: center; justify-content: center; position: relative;
  }
  .slot.selected { border-color: white; background: #bbb; }
  .slot-icon { width: 32px; height: 32px; image-rendering: pixelated; }
</style>
</head>
<body>

<div id="loading-screen">
  <div id="loading-text">REINFORCING PHYSICS... 0%</div>
  <div id="progress-bar-box"><div id="progress-bar"></div></div>
</div>

<div id="game-ui">
  <div id="crosshair"></div>
  <div id="ui-container"><div id="hotbar"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- SETTINGS ---
const RENDER_DIST = 8;
const SPEED_WALK = 0.08; 
const JUMP_FORCE = 0.22;
const GRAVITY = 0.015;
const PLAYER_RADIUS = 0.3;
const PLAYER_HEIGHT = 1.7;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 20, 50);

const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xffffff, 0.6);
sun.position.set(20, 50, 20);
scene.add(sun);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- TEXTURES ---
const canvas = document.createElement("canvas");
canvas.width = 16; canvas.height = 16;
const ctx = canvas.getContext("2d");

function makeTex(colors, overlayFn) {
    for(let i=0; i<256; i++) {
        ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
        ctx.fillRect(i%16, Math.floor(i/16), 1, 1);
    }
    if(overlayFn) overlayFn(ctx);
    const t = new THREE.CanvasTexture(canvas);
    t.magFilter = THREE.NearestFilter;
    const url = canvas.toDataURL();
    const copy = document.createElement("canvas");
    copy.width=16; copy.height=16; copy.getContext("2d").drawImage(canvas,0,0);
    const t2 = new THREE.CanvasTexture(copy); t2.magFilter = THREE.NearestFilter;
    return { tex: t2, icon: url };
}

const grassTop = makeTex(["#4caf50", "#388e3c"]);
const grassSide = makeTex(["#795548", "#5d4037"], c => { c.fillStyle="#4caf50"; c.fillRect(0,0,16,4); });
const stone = makeTex(["#9e9e9e", "#757575"]);

const materials = [
    [new THREE.MeshLambertMaterial({map:grassSide.tex}), new THREE.MeshLambertMaterial({map:grassSide.tex}), new THREE.MeshLambertMaterial({map:grassTop.tex}), new THREE.MeshLambertMaterial({map:grassSide.tex}), new THREE.MeshLambertMaterial({map:grassSide.tex}), new THREE.MeshLambertMaterial({map:grassSide.tex})],
    new THREE.MeshLambertMaterial({map:stone.tex})
];

const blocks = {};
const boxGeo = new THREE.BoxGeometry(1,1,1);

function spawn(x, y, z, type) {
    const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
    if(blocks[key]) return;
    const mesh = new THREE.Mesh(boxGeo, materials[type]);
    mesh.position.set(x, y, z);
    mesh.userData = { type, hp: (type===1?60:20), key };
    scene.add(mesh);
    blocks[key] = mesh;
}

// --- WORLD GEN ---
function getHeight(x, z) { return Math.floor(Math.sin(x/10)*3 + Math.cos(z/10)*3); }

let gX = -RENDER_DIST, gZ = -RENDER_DIST;
function loadBatch() {
    for(let i=0; i<60; i++) {
        if(gX > RENDER_DIST) { start(); return; }
        const h = getHeight(gX, gZ);
        for(let y=-2; y<=h; y++) spawn(gX, y, gZ, y===h ? 0 : 1);
        gZ++; if(gZ > RENDER_DIST) { gZ = -RENDER_DIST; gX++; }
    }
    const p = Math.floor(((gX + RENDER_DIST) / (RENDER_DIST*2)) * 100);
    document.getElementById("progress-bar").style.width = p + "%";
    document.getElementById("loading-text").innerText = `STRENGTHENING WORLD... ${p}%`;
    requestAnimationFrame(loadBatch);
}

// --- PHYSICS ENGINE ---
function isBlockAt(x, y, z) {
    const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
    return blocks[key] ? true : false;
}

function checkCollision(pos) {
    // Check player "hitbox" corners
    for(let x = -PLAYER_RADIUS; x <= PLAYER_RADIUS; x += PLAYER_RADIUS*2) {
        for(let z = -PLAYER_RADIUS; z <= PLAYER_RADIUS; z += PLAYER_RADIUS*2) {
            for(let y = 0; y <= PLAYER_HEIGHT; y += PLAYER_HEIGHT/2) {
                if(isBlockAt(pos.x + x, pos.y - 1.6 + y, pos.z + z)) return true;
            }
        }
    }
    return false;
}

// --- INPUTS ---
const keys = {};
let yaw = 0, pitch = 0;
let velY = 0;
let isMining = false;
let miningProgress = 0;
let miningTarget = null;

document.onkeydown = e => keys[e.code] = true;
document.onkeyup = e => keys[e.code] = false;
document.body.onclick = () => document.body.requestPointerLock();
document.onmousedown = e => { if(e.button === 0) isMining = true; };
document.onmouseup = () => { 
    isMining = false; 
    miningProgress = 0; 
    if(miningTarget) miningTarget.position.set(...miningTarget.userData.key.split(',').map(Number)); 
};
document.onmousemove = e => {
    if(document.pointerLockElement) {
        yaw -= e.movementX * 0.002; pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
    }
};

function start() {
    document.getElementById("loading-screen").style.display = "none";
    document.getElementById("game-ui").style.visibility = "visible";
    camera.position.set(0, 5, 0);
    animate();
    setInterval(updateChunks, 1000);
}

function updateChunks() {
    const px = Math.floor(camera.position.x), pz = Math.floor(camera.position.z);
    for(let x=px-RENDER_DIST; x<=px+RENDER_DIST; x++) {
        for(let z=pz-RENDER_DIST; z<=pz+RENDER_DIST; z++) {
            const h = getHeight(x,z);
            if(!blocks[`${x},${h},${z}`]) spawn(x, h, z, 0);
        }
    }
}

const ray = new THREE.Raycaster();
function animate() {
    requestAnimationFrame(animate);

    // 1. Rotation
    camera.rotation.set(pitch, yaw, 0);

    // 2. Horizontal Movement
    const move = new THREE.Vector3();
    if(keys["KeyW"]) move.z -= 1; if(keys["KeyS"]) move.z += 1;
    if(keys["KeyA"]) move.x -= 1; if(keys["KeyD"]) move.x += 1;
    move.applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize().multiplyScalar(SPEED_WALK);

    // X-Collision
    const nextX = camera.position.clone(); nextX.x += move.x;
    if(!checkCollision(nextX)) camera.position.x += move.x;
    
    // Z-Collision
    const nextZ = camera.position.clone(); nextZ.z += move.z;
    if(!checkCollision(nextZ)) camera.position.z += move.z;

    // 3. Vertical Physics (Gravity/Jump)
    velY -= GRAVITY;
    const nextY = camera.position.clone(); nextY.y += velY;
    
    if(checkCollision(nextY)) {
        if(velY < 0) { // Hitting floor
            if(keys["Space"]) velY = JUMP_FORCE;
            else velY = 0;
        } else { // Hitting ceiling
            velY = 0;
        }
    } else {
