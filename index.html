<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 3: Deep World & Flight</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  
  #crosshair {
    position: fixed; top: 50%; left: 50%;
    width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px;
    border: 2px solid white; box-sizing: border-box;
    pointer-events: none; z-index: 10;
  }

  #ui {
    position: fixed; bottom: 10px; left: 50%;
    transform: translateX(-50%);
    text-align: center; pointer-events: none;
  }

  /* FLIGHT INDICATOR */
  #fly-mode {
    position: fixed; top: 10px; left: 10px;
    color: yellow; font-weight: bold; font-size: 18px;
    text-shadow: 2px 2px 0 #000; display: none;
  }

  #hotbar {
    display: flex; gap: 4px; justify-content: center; margin-top: 6px;
  }
  
  .slot {
    width: 50px; height: 50px; background: rgba(0,0,0,0.5); 
    border: 3px solid #333;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    position: relative;
  }
  .slot.selected { border-color: white; background: rgba(0,0,0,0.2); }
  
  .icon { width: 24px; height: 24px; border: 1px solid #000; margin-bottom: 2px; box-shadow: 2px 2px 0 rgba(0,0,0,0.5); }
  
  .tool-pick { background: linear-gradient(135deg, #eee 50%, #8b4513 50%); }
  .tool-axe  { background: linear-gradient(135deg, #8b4513 30%, #eee 30%); }
  .tool-shovel { background: linear-gradient(to bottom, #eee 40%, #8b4513 40%); }

  .count { font-size: 14px; color: white; text-shadow: 1px 1px 0 #000; }
  .key-bind { position: absolute; top: 2px; left: 2px; font-size: 10px; color: #ccc; }
</style>
</head>
<body>

<div id="crosshair"></div>
<div id="fly-mode">FLYING MODE ENABLED</div>

<div id="ui">
  <div id="hotbar">
    <div class="slot selected" id="slot-0"><span class="key-bind">1</span><div class="icon" style="background:#2e7d32"></div><span class="count">0</span></div>
    <div class="slot" id="slot-1"><span class="key-bind">2</span><div class="icon" style="background:#777"></div><span class="count">0</span></div>
    <div class="slot" id="slot-2"><span class="key-bind">3</span><div class="icon" style="background:#5c4033"></div><span class="count">0</span></div>
    <div class="slot" id="slot-3"><span class="key-bind">4</span><div class="icon" style="background:#4caf50"></div><span class="count">0</span></div>
    <div style="width: 10px;"></div>
    <div class="slot" id="slot-4"><span class="key-bind">5</span><div class="icon tool-pick"></div></div>
    <div class="slot" id="slot-5"><span class="key-bind">6</span><div class="icon tool-axe"></div></div>
    <div class="slot" id="slot-6"><span class="key-bind">7</span><div class="icon tool-shovel"></div></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- PHYSICS TUNING 2.0 (SNAPPY) ---
const SPEED_WALK = 0.14;   
const SPEED_SPRINT = 0.24; 
const SPEED_FLY = 0.35;    // Flying is fast

// To make jumping "lower and faster", we increase gravity AND lower jump force slightly
const JUMP_FORCE = 0.27;   // Lower (was 0.32)
const GRAVITY = 0.022;     // Much heavier (was 0.016)

// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 10, 25);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 10);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

// --- TEXTURES ---
function makeTexture(colors) {
  const c = document.createElement("canvas");
  c.width = c.height = 16;
  const ctx = c.getContext("2d");
  for (let y = 0; y < 16; y++) {
    for (let x = 0; x < 16; x++) {
      ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
      ctx.fillRect(x, y, 1, 1);
    }
  }
  const tex = new THREE.CanvasTexture(c);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestFilter;
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}

const texGrassTop = makeTexture(["#3fa34d", "#2e7d32", "#3fa34d"]);
const texGrassSide = makeTexture(["#7a5a2e", "#6b4f28", "#7a5a2e", "#3fa34d"]);
const texDirt = makeTexture(["#7a5a2e", "#6b4f28"]);
const texStone = makeTexture(["#888888", "#777777", "#999999"]);
const texWoodSide = makeTexture(["#5c4033", "#4e342e", "#3e2723"]);
const texWoodTop = makeTexture(["#8d6e63", "#795548"]);
const texLeaves = makeTexture(["#4caf50", "#388e3c", "#66bb6a"]);
const texBedrock = makeTexture(["#222", "#333", "#111", "#000"]); // Dark, messy texture

const materials = [
  // 0: GRASS
  [
    new THREE.MeshLambertMaterial({ map: texGrassSide }), 
    new THREE.MeshLambertMaterial({ map: texGrassSide }), 
    new THREE.MeshLambertMaterial({ map: texGrassTop }),  
    new THREE.MeshLambertMaterial({ map: texDirt }),      
    new THREE.MeshLambertMaterial({ map: texGrassSide }), 
    new THREE.MeshLambertMaterial({ map: texGrassSide })  
  ],
  // 1: STONE
  new THREE.MeshLambertMaterial({ map: texStone }),
  // 2: WOOD
  [
    new THREE.MeshLambertMaterial({ map: texWoodSide }), 
    new THREE.MeshLambertMaterial({ map: texWoodSide }), 
    new THREE.MeshLambertMaterial({ map: texWoodTop }),  
    new THREE.MeshLambertMaterial({ map: texWoodTop }),  
    new THREE.MeshLambertMaterial({ map: texWoodSide }), 
    new THREE.MeshLambertMaterial({ map: texWoodSide })  
  ],
  // 3: LEAVES
  new THREE.MeshLambertMaterial({ map: texLeaves }),
  // 4: BEDROCK
  new THREE.MeshLambertMaterial({ map: texBedrock })
];

const BLOCK_HP = { 0: 2, 1: 3, 2: 3, 3: 1, 4: 999999 }; // Bedrock is unbreakable

// --- GAME VARIABLES ---
let yaw = 0;
let pitch = 0;
const keys = {};
let velocityY = 0;
let onGround = false;
let sprint = false;
let flying = false; // Flight toggle

let targetFov = 75;

const inventory = [0, 0, 0, 0, 1, 1, 1]; 
let selectedSlot = 0; 
const blocks = [];       
const droppedItems = []; 
const boxGeo = new THREE.BoxGeometry(1, 1, 1);

// --- INPUTS ---
document.addEventListener("keydown", e => {
  keys[e.code] = true;
  if (e.code === "ShiftLeft") sprint = true;
  
  // Jump logic (only if not flying)
  if (e.code === "Space" && onGround && !flying) {
    velocityY = JUMP_FORCE; 
    onGround = false;
  }
  
  // Toggle Flight (Key: F)
  if (e.code === "KeyF") {
    flying = !flying;
    velocityY = 0;
    document.getElementById("fly-mode").style.display = flying ? "block" : "none";
  }

  // Hotbar
  if (e.key >= "1" && e.key <= "7") {
    selectedSlot = parseInt(e.key) - 1;
    updateUI();
  }
});

document.addEventListener("keyup", e => {
  keys[e.code] = false;
  if (e.code === "ShiftLeft") sprint = false;
});

document.body.addEventListener("click", () => document.body.requestPointerLock());
window.addEventListener('contextmenu', e => e.preventDefault());

document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === document.body) {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
  }
});

// --- LIGHTING ---
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(50, 100, 50);
scene.add(sun);

// --- WORLD GEN ---
function createBlock(x, y, z, type) {
  const mat = materials[type];
  let finalMat;
  if (Array.isArray(mat)) finalMat = mat.map(m => m.clone());
  else finalMat = mat.clone();

  const mesh = new THREE.Mesh(boxGeo, finalMat);
  mesh.position.set(x, y, z);
  mesh.userData = { type: type, hp: BLOCK_HP[type] || 1 }; 
  scene.add(mesh);
  blocks.push(mesh);
  return mesh;
}

function createTree(x, z) {
  const height = 3 + Math.floor(Math.random() * 2);
  for (let y = 1; y <= height; y++) createBlock(x, y, z, 2);
  for (let lx = x - 2; lx <= x + 2; lx++) {
    for (let lz = z - 2; lz <= z + 2; lz++) {
      for (let ly = height; ly <= height + 1; ly++) {
        if (Math.abs(lx - x) + Math.abs(lz - z) <= 2) {
           if (!(lx === x && lz === z && ly === height)) createBlock(lx, ly, lz, 3);
        }
      }
    }
  }
  createBlock(x, height + 2, z, 3);
}

const worldSize = 12; 
for (let x = -worldSize; x < worldSize; x++) {
  for (let z = -worldSize; z < worldSize; z++) {
    createBlock(x, 0, z, 0); // Grass
    for (let y = -1; y > -5; y--) createBlock(x, y, z, 1); // Stone
    createBlock(x, -5, z, 4); // BEDROCK at bottom
    if (Math.random() < 0.025 && (Math.abs(x) > 3 || Math.abs(z) > 3)) createTree(x, z);
  }
}

// --- INTERACTION ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(0, 0);

function flashBlock(block) {
  const mats = Array.isArray(block.material) ? block.material : [block.material];
  mats.forEach(m => m.emissive.setHex(0xff0000));
  setTimeout(() => {
    mats.forEach(m => m.emissive.setHex(0x000000));
  }, 100);
}

document.addEventListener("mousedown", e => {
  if (document.pointerLockElement !== document.body) return;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(blocks);
  if (hits.length === 0) return;

  const hit = hits[0];
  const hitBlock = hit.object;
  const blockType = hitBlock.userData.type;
  
  // Bedrock Check
  if (blockType === 4) return; // Cannot interact with bedrock

  // MINE
  if (e.button === 0) {
    let damage = 1; 
    if (selectedSlot === 4 && blockType === 1) damage = 10; 
    if (selectedSlot === 5 && blockType === 2) damage = 10; 
    if (selectedSlot === 6 && (blockType === 0 || blockType === 3)) damage = 10; 

    // Creative mode = instant mine? Optional, but let's keep HP for now so you can use tools
    if (flying) damage = 100; // Super strength when flying

    hitBlock.userData.hp -= damage;
    flashBlock(hitBlock);

    if (hitBlock.userData.hp <= 0) {
      const drop = new THREE.Mesh(boxGeo, hitBlock.material); 
      drop.scale.set(0.25, 0.25, 0.25);
      drop.position.copy(hitBlock.position);
      drop.userData = { isDrop: true, velocityY: 0.3, type: blockType };
      droppedItems.push(drop);
      scene.add(drop);
      scene.remove(hitBlock);
      blocks.splice(blocks.indexOf(hitBlock), 1);
    }
  } 
  // PLACE
  else if (e.button === 2) {
    if (selectedSlot <= 3 && inventory[selectedSlot] > 0) {
      const newPos = hitBlock.position.clone().add(hit.face.normal);
      const playerPos = camera.position.clone();
      playerPos.y -= 1.6;
      if (newPos.distanceTo(playerPos) < 1.0) return;
      createBlock(newPos.x, newPos.y, newPos.z, selectedSlot);
      // If flying, don't use ammo (Creative mode style)
      if (!flying) {
        inventory[selectedSlot]--;
        updateUI();
      }
    }
  }
});

function updateUI() {
  const slots = document.querySelectorAll(".slot");
  slots.forEach((slot, index) => {
    if (index === selectedSlot) slot.classList.add("selected");
    else slot.classList.remove("selected");
    if (index < 4) slot.querySelector(".count").innerText = inventory[index];
  });
}

// --- ANIMATION LOOP ---
const downRay = new THREE.Raycaster();

function animate() {
  requestAnimationFrame(animate);

  camera.rotation.y = yaw;
  camera.rotation.x = pitch;

  // PHYSICS: MOVEMENT
  const speed = flying ? SPEED_FLY : (sprint ? SPEED_SPRINT : SPEED_WALK);
  const dir = new THREE.Vector3();
  const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
  const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)).normalize();

  if (keys["KeyW"]) dir.add(forward);
  if (keys["KeyS"]) dir.sub(forward);
  if (keys["KeyA"]) dir.sub(right);
  if (keys["KeyD"]) dir.add(right);

  // FLIGHT VERTICAL MOVEMENT
  if (flying) {
    if (keys["Space"]) camera.position.y += speed;
    if (keys["ShiftLeft"]) camera.position.y -= speed;
  }

  // FOV EFFECTS
  if (sprint && dir.length() > 0 && !flying) targetFov = 85;
  else if (dir.length() > 0 && !flying) targetFov = 77;
  else targetFov = 75;
  camera.fov += (targetFov - camera.fov) * 0.1;
  camera.updateProjectionMatrix();

  if (dir.length() > 0) {
    dir.normalize();
    const origin = camera.position.clone();
    origin.y -= 1.0; 
    const moveRay = new THREE.Raycaster(origin, dir, 0, 0.5);
    if (moveRay.intersectObjects(blocks).length === 0) {
      camera.position.addScaledVector(dir, speed);
    }
  }

  // GRAVITY
  if (flying) {
    velocityY = 0; // No gravity when flying
  } else {
    // Normal Gravity Logic
    if (!onGround) velocityY -= GRAVITY; 
    camera.position.y += velocityY;

    downRay.set(camera.position, new THREE.Vector3(0, -1, 0));
    const groundHits = downRay.intersectObjects(blocks);
    if (groundHits.length > 0) {
      const hit = groundHits[0];
      if (hit.distance < 1.8 && velocityY <= 0) {
        camera.position.y = hit.point.y + 1.8;
        velocityY = 0;
        onGround = true;
      } else {
        onGround = false;
      }
    } else {
      onGround = false;
    }
  }

  // Fall off world check (Respawn or bounce if flight off)
  if (camera.position.y < -20 && !flying) {
    camera.position.set(0, 10, 0);
    velocityY = 0;
  }

  // DROPS
  for (let i = droppedItems.length - 1; i >= 0; i--) {
    const item = droppedItems[i];
    item.userData.velocityY -= GRAVITY;
    item.position.y += item.userData.velocityY;
    
    if (item.position.y < Math.floor(item.position.y) + 0.5) {
       item.position.y = Math.floor(item.position.y) + 0.5;
       item.userData.velocityY = 0;
    }
    item.rotation.y += 0.05;

    if (camera.position.distanceTo(item.position) < 1.5) {
      const type = item.userData.type;
      if (type <= 3) { 
        inventory[type]++;
        updateUI();
      }
      scene.remove(item);
      droppedItems.splice(i, 1);
    }
  }

  renderer.render(scene, camera);
}

updateUI();
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
