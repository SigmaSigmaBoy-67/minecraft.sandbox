<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft-Style 3D</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; }
  #crosshair {
    position: fixed; top: 50%; left: 50%;
    width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px;
    border: 2px solid white; box-sizing: border-box;
    pointer-events: none;
  }
  #ui {
    position: fixed; bottom: 10px; left: 50%;
    transform: translateX(-50%);
    text-align: center; pointer-events: none;
    font-family: monospace;
  }
  #hotbar {
    display: flex; gap: 4px; justify-content: center; margin-top: 6px;
  }
  .slot {
    width: 40px; height: 40px; background: #777; border: 3px solid #333;
  }
  .slot.selected { border-color: white; }
</style>
</head>
<body>

<div id="crosshair"></div>
<div id="ui">
  <div id="hotbar">
    <div class="slot selected"></div>
    <div class="slot"></div>
    <div class="slot"></div>
    <div class="slot"></div>
    <div class="slot"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

// --- VARIABLES ---
let yaw = 0;
let pitch = 0;
const keys = {};
let velocityY = 0;
let onGround = false;
let sprint = false;

// --- INPUTS ---
document.addEventListener("keydown", e => {
  keys[e.code] = true;
  if (e.code === "ShiftLeft") sprint = true;
  if (e.code === "Space" && onGround) {
    velocityY = 0.25; // Jump force
    onGround = false;
  }
});
document.addEventListener("keyup", e => {
  keys[e.code] = false;
  if (e.code === "ShiftLeft") sprint = false;
});
document.body.addEventListener("click", () => document.body.requestPointerLock());
document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === document.body) {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
  }
});

// --- LIGHTS & TEXTURES ---
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.7);
sun.position.set(50, 100, 50);
scene.add(sun);

function makeColorTex(color) {
  const c = document.createElement("canvas");
  c.width = c.height = 16;
  const ctx = c.getContext("2d");
  ctx.fillStyle = color;
  ctx.fillRect(0,0,16,16);
  // Add some noise
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  if(Math.random() > 0.5) ctx.fillRect(0,0,8,8);
  if(Math.random() > 0.5) ctx.fillRect(8,8,8,8);
  
  const tex = new THREE.CanvasTexture(c);
  tex.magFilter = THREE.NearestFilter;
  return tex;
}

const matGrass = new THREE.MeshLambertMaterial({ map: makeColorTex("#2e7d32") });
const matStone = new THREE.MeshLambertMaterial({ map: makeColorTex("#777777") });

// --- WORLD GEN ---
const blocks = [];
const boxGeo = new THREE.BoxGeometry(1, 1, 1);

for (let x = -10; x < 10; x++) {
  for (let z = -10; z < 10; z++) {
    // Grass
    const grass = new THREE.Mesh(boxGeo, matGrass);
    grass.position.set(x, 0, z);
    scene.add(grass);
    blocks.push(grass);
    // Stone
    for (let y = -1; y > -4; y--) {
      const s = new THREE.Mesh(boxGeo, matStone);
      s.position.set(x, y, z);
      scene.add(s);
      blocks.push(s);
    }
  }
}

// --- RAYCASTERS ---
const raycaster = new THREE.Raycaster();
const downRay = new THREE.Raycaster();
const mouse = new THREE.Vector2(0, 0);

// --- INTERACTION (BREAK BLOCKS) ---
document.addEventListener("mousedown", e => {
  if (document.pointerLockElement !== document.body) return;
  if (e.button !== 0) return; // Left click only

  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(blocks);

  if (hits.length > 0) {
    const hit = hits[0].object;
    scene.remove(hit); // Remove from scene
    blocks.splice(blocks.indexOf(hit), 1); // Remove from physics list
  }
});

// --- ANIMATION LOOP ---
function animate() {
  requestAnimationFrame(animate);

  // Look
  camera.rotation.y = yaw;
  camera.rotation.x = pitch;

  // Move
  const speed = sprint ? 0.15 : 0.08;
  const dir = new THREE.Vector3();
  const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
  const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)).normalize();

  if (keys["KeyW"]) dir.add(forward);
  if (keys["KeyS"]) dir.sub(forward);
  if (keys["KeyA"]) dir.sub(right);
  if (keys["KeyD"]) dir.add(right);

  // Collision (Wall)
  if (dir.length() > 0) {
    dir.normalize();
    const origin = camera.position.clone();
    origin.y -= 1.0; 
    const moveRay = new THREE.Raycaster(origin, dir, 0, 0.5);
    if (moveRay.intersectObjects(blocks).length === 0) {
      camera.position.addScaledVector(dir, speed);
    }
  }

  // Gravity
  if (!onGround) velocityY -= 0.01;
  camera.position.y += velocityY;

  // Collision (Ground)
  downRay.set(camera.position, new THREE.Vector3(0, -1, 0));
  const groundHits = downRay.intersectObjects(blocks);
  if (groundHits.length > 0) {
    const hit = groundHits[0];
    if (hit.distance < 1.8 && velocityY <= 0) {
      camera.position.y = hit.point.y + 1.8;
      velocityY = 0;
      onGround = true;
    } else {
      onGround = false;
    }
  } else {
    onGround = false;
  }

  renderer.render(scene, camera);
}

animate();

// --- RESIZE ---
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
