<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 12: Instant Play</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  #crosshair {
    position: fixed; top: 50%; left: 50%; width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px; border: 2px solid white; pointer-events: none; z-index: 10;
  }
  #ui { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); pointer-events: none; }
  #hotbar { display: flex; gap: 5px; background: rgba(0,0,0,0.4); padding: 8px; border-radius: 4px; border: 2px solid #333; }
  .slot { width: 40px; height: 40px; background: #8b8b8b; border: 3px solid #373737; display: flex; align-items: center; justify-content: center; }
  .slot.selected { border-color: white; background: #bbb; }
  .slot-icon { width: 30px; height: 30px; image-rendering: pixelated; }
  #msg { position: fixed; top: 10px; left: 10px; color: white; text-shadow: 1px 1px 2px black; font-size: 14px; }
</style>
</head>
<body>

<div id="msg">WASD Move | SPACE Jump | HOLD LEFT CLICK to Mine | RIGHT CLICK Place</div>
<div id="crosshair"></div>
<div id="ui"><div id="hotbar"></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- SETTINGS ---
const SPEED = 0.1; 
const JUMP = 0.22;
const GRAVITY = 0.015;
const GEN_RANGE = 12; // How far to generate land

// --- INITIALIZE ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 15, 50);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambient);

// --- TEXTURES ---
const canvas = document.createElement("canvas");
canvas.width = 16; canvas.height = 16;
const ctx = canvas.getContext("2d");

function makeTex(colors, sideColor = null) {
    for(let i=0; i<256; i++) {
        ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
        ctx.fillRect(i%16, Math.floor(i/16), 1, 1);
    }
    const icon = canvas.toDataURL();
    const t = new THREE.CanvasTexture(canvas);
    t.magFilter = THREE.NearestFilter;
    
    let mats;
    if(sideColor) {
        const sideCanvas = document.createElement("canvas");
        sideCanvas.width = 16; sideCanvas.height = 16;
        const sCtx = sideCanvas.getContext("2d");
        for(let i=0; i<256; i++) {
            sCtx.fillStyle = ["#795548", "#5d4037"][Math.floor(Math.random()*2)];
            sCtx.fillRect(i%16, Math.floor(i/16), 1, 1);
        }
        sCtx.fillStyle = sideColor;
        sCtx.fillRect(0,0,16,4);
        const sTex = new THREE.CanvasTexture(sideCanvas);
        sTex.magFilter = THREE.NearestFilter;
        mats = [
            new THREE.MeshLambertMaterial({map: sTex}), new THREE.MeshLambertMaterial({map: sTex}),
            new THREE.MeshLambertMaterial({map: t}),    new THREE.MeshLambertMaterial({map: sTex}),
            new THREE.MeshLambertMaterial({map: sTex}), new THREE.MeshLambertMaterial({map: sTex})
        ];
    } else {
        mats = new THREE.MeshLambertMaterial({map: t});
    }
    return { mats, icon };
}

const grass = makeTex(["#4caf50", "#388e3c"], "#4caf50");
const stone = makeTex(["#9e9e9e", "#757575"]);
const wood = makeTex(["#5d4037", "#4e342e"]);

const blocks = {};
const boxGeo = new THREE.BoxGeometry(1, 1, 1);

function spawnBlock(x, y, z, type) {
    const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
    if (blocks[key]) return;
    const mesh = new THREE.Mesh(boxGeo, type === 0 ? grass.mats : (type === 1 ? stone.mats : wood.mats));
    mesh.position.set(Math.floor(x), Math.floor(y), Math.floor(z));
    mesh.userData = { type, hp: type === 1 ? 50 : 20, key };
    scene.add(mesh);
    blocks[key] = mesh;
}

// --- WORLD GENERATION ---
function getHeight(x, z) {
    return Math.floor(Math.sin(x/8)*2 + Math.cos(z/8)*2);
}

function generateArea(cx, cz, range) {
    for(let x = cx - range; x <= cx + range; x++) {
        for(let z = cz - range; z <= cz + range; z++) {
            const h = getHeight(x, z);
            // Spawn surface and 2 blocks below
            spawnBlock(x, h, z, 0);
            spawnBlock(x, h-1, z, 1);
            spawnBlock(x, h-2, z, 1);
        }
    }
}

// --- PHYSICS ---
function isSolid(x, y, z) {
    return blocks[`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`] ? true : false;
}

function checkPlayerCollision(pos) {
    const r = 0.3; // Player radius
    const h = 1.7; // Player height
    const offsets = [[r,r], [r,-r], [-r,r], [-r,-r], [0,0]];
    for(let o of offsets) {
        // Check feet, waist, and head
        if(isSolid(pos.x + o[0], pos.y - 1.6, pos.z + o[1])) return true;
        if(isSolid(pos.x + o[0], pos.y - 0.8, pos.z + o[1])) return true;
        if(isSolid(pos.x + o[0], pos.y, pos.z + o[1])) return true;
    }
    return false;
}

// --- CONTROLS ---
const keys = {};
let yaw = 0, pitch = 0, velY = 0;
let mining = false, miningProgress = 0, miningTarget = null;
let selected = 0;

document.onkeydown = (e) => {
    keys[e.code] = true;
    if(e.key >= '1' && e.key <= '3') {
        selected = parseInt(e.key) - 1;
        document.querySelectorAll('.slot').forEach((s, i) => s.className = i === selected ? 'slot selected' : 'slot');
    }
};
document.onkeyup = (e) => keys[e.code] = false;
document.onmousemove = (e) => {
    if(document.pointerLockElement) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
    }
};
document.onmousedown = (e) => {
    if(!document.pointerLockElement) document.body.requestPointerLock();
    else if(e.button === 0) mining = true;
    else if(e.button === 2) placeBlock();
};
document.onmouseup = () => { mining = false; miningProgress = 0; if(miningTarget) miningTarget.position.set(...miningTarget.userData.key.split(',').map(Number)); };

const ray = new THREE.Raycaster();
function placeBlock() {
    ray.setFromCamera(new THREE.Vector2(), camera);
    const hits = ray.intersectObjects(Object.values(blocks));
    if(hits.length > 0 && hits[0].distance < 4) {
        const p = hits[0].object.position.clone().add(hits[0].face.normal);
        spawnBlock(p.x, p.y, p.z, selected);
    }
}

// --- START ---
camera.position.set(0, 5, 0);
generateArea(0, 0, GEN_RANGE);

function animate() {
    requestAnimationFrame(animate);

    camera.rotation.set(pitch, yaw, 0);

    // Movement
    const move = new THREE.Vector3();
    if(keys["KeyW"]) move.z -= 1; if(keys["KeyS"]) move.z += 1;
    if(keys["KeyA"]) move.x -= 1; if(keys["KeyD"]) move.x += 1;
    move.applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize().multiplyScalar(SPEED);

    const nextX = camera.position.clone(); nextX.x += move.x;
    if(!checkPlayerCollision(nextX)) camera.position.x += move.x;
    const nextZ = camera.position.clone(); nextZ.z += move.z;
    if(!checkPlayerCollision(nextZ)) camera.position.z += move.z;

    // Gravity
    velY -= GRAVITY;
    const nextY = camera.position.clone(); nextY.y += velY;
    if(checkPlayerCollision(nextY)) {
        if(velY < 0 && keys["Space"]) velY = JUMP;
        else velY = 0;
    } else {
        camera.position.y += velY;
    }

    // Dynamic Gen
    if(Math.random() < 0.1) generateArea(camera.position.x, camera.position.z, GEN_RANGE);

    // Mining
    if(mining) {
        ray.setFromCamera(new THREE.Vector2(), camera);
        const hits = ray.intersectObjects(Object.values(blocks));
        if(hits.length > 0 && hits[0].distance < 4) {
            const b = hits[0].object;
            miningTarget = b;
            miningProgress++;
            b.position.x = Number(b.userData.key.split(',')[0]) + Math.sin(miningProgress)*0.04;
            if(miningProgress >= b.userData.hp) {
                scene.remove(b); delete blocks[b.userData.key]; miningProgress = 0;
            }
        }
    }

    renderer.render(scene, camera);
}

// UI Setup
const bar = document.getElementById("hotbar");
[grass, stone, wood].forEach((t, i) => {
    bar.innerHTML += `<div class="slot ${i===0?'selected':''}"><img src="${t.icon}" class="slot-icon"></div>`;
});

animate();
window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
</script>
</body>
</html>
