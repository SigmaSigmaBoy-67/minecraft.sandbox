<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 5.5: Stability Fix</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  
  #crosshair {
    position: fixed; top: 50%; left: 50%;
    width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px;
    border: 2px solid white; box-sizing: border-box;
    pointer-events: none; z-index: 10;
  }

  #ui {
    position: fixed; bottom: 10px; left: 50%;
    transform: translateX(-50%);
    text-align: center; pointer-events: none;
  }

  #overlay-text {
    position: fixed; top: 10px; left: 10px;
    color: white; font-weight: bold; font-size: 16px;
    text-shadow: 1px 1px 0 #000;
  }
  
  #hotbar {
    display: flex; gap: 4px; justify-content: center; margin-top: 6px;
    background: rgba(0,0,0,0.2); padding: 5px; border-radius: 5px;
  }
  
  .slot {
    width: 44px; height: 44px; background: #8b8b8b; 
    border: 3px solid #373737;
    border-top: 3px solid #FFF; border-left: 3px solid #FFF;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    position: relative;
  }
  .slot.selected { background: #bbb; border-color: white; }
  
  .slot-icon { width: 32px; height: 32px; image-rendering: pixelated; }
  .count { position: absolute; bottom: 2px; right: 2px; font-size: 14px; color: white; text-shadow: 2px 2px 0 #000; }
  .key-bind { position: absolute; top: 2px; left: 2px; font-size: 10px; color: #444; font-weight: bold; }
</style>
</head>
<body>

<div id="crosshair"></div>
<div id="overlay-text">GENERATING WORLD...</div>

<div id="ui">
  <div id="hotbar"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- CONFIGURATION ---
const RENDER_DISTANCE = 8; // Reduced from 14 for stability
const WORLD_BORDER = 1000;
const SPEED_WALK = 0.14;   
const SPEED_SPRINT = 0.24; 
const SPEED_FLY = 0.40;    
const JUMP_FORCE = 0.27;   
const GRAVITY = 0.022;     

// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 8, 20); // Closer fog for performance

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

// --- TEXTURE SYSTEM ---
const textureCanvas = document.createElement("canvas");
textureCanvas.width = 16; textureCanvas.height = 16;
const ctx = textureCanvas.getContext("2d");

function createTexture(drawFn) {
  ctx.clearRect(0,0,16,16);
  drawFn(ctx);
  const tex = new THREE.CanvasTexture(textureCanvas);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestFilter;
  tex.colorSpace = THREE.SRGBColorSpace;
  const dataUrl = textureCanvas.toDataURL();
  const copy = document.createElement("canvas");
  copy.width=16; copy.height=16;
  copy.getContext("2d").drawImage(textureCanvas,0,0);
  const distinctTex = new THREE.CanvasTexture(copy);
  distinctTex.magFilter = THREE.NearestFilter;
  distinctTex.colorSpace = THREE.SRGBColorSpace;
  return { tex: distinctTex, icon: dataUrl };
}

function fillNoise(ctx, colors) {
  for(let y=0; y<16; y++) {
    for(let x=0; x<16; x++) {
      ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
      ctx.fillRect(x,y,1,1);
    }
  }
}

function drawPixels(ctx, map, palette) {
  for(let y=0; y<16; y++) {
    for(let x=0; x<16; x++) {
      const char = map[y][x];
      if (char !== " ") {
        ctx.fillStyle = palette[char];
        ctx.fillRect(x,y,1,1);
      }
    }
  }
}

// DEFINING TEXTURES
const tGrassTop = createTexture(c => fillNoise(c, ["#4caf50", "#388e3c"]));
const tGrassSide = createTexture(c => { fillNoise(c, ["#795548", "#5d4037"]); c.fillStyle = "#4caf50"; c.fillRect(0,0,16,4); });
const tDirt = createTexture(c => fillNoise(c, ["#795548", "#5d4037"]));
const tStone = createTexture(c => fillNoise(c, ["#9e9e9e", "#757575", "#616161"]));
const tWood = createTexture(c => { fillNoise(c, ["#5d4037", "#4e342e"]); c.fillStyle = "#3e2723"; c.fillRect(4,0,2,16); c.fillRect(10,0,2,16); });
const tLeaves = createTexture(c => fillNoise(c, ["#2e7d32", "#1b5e20", "#4caf50"]));
const tIron = createTexture(c => { fillNoise(c, ["#9e9e9e", "#757575"]); c.fillStyle = "#d7ccc8"; for(let i=0; i<8; i++) c.fillRect(Math.random()*14+1, Math.random()*14+1, 2, 2); });
const tDiamond = createTexture(c => { fillNoise(c, ["#9e9e9e", "#757575"]); c.fillStyle = "#00bcd4"; for(let i=0; i<6; i++) c.fillRect(Math.random()*14+1, Math.random()*14+1, 2, 2); });
const tBedrock = createTexture(c => fillNoise(c, ["#000", "#222", "#111"]));

const pickMap = ["   BBBB         ", "   B  B         ", "   B  B         ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          "];
const axeMap = ["   BB           ", "  BBBB          ", "  BBBB          ", "   BSS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          ", "    SS          "];
const shovelMap = ["    B           ", "   BBB          ", "   BBB          ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           ", "    S           "];

const tPickaxe = createTexture(c => drawPixels(c, pickMap, {B:"#555", S:"#8d6e63"}));
const tAxe = createTexture(c => drawPixels(c, axeMap, {B:"#555", S:"#8d6e63"}));
const tShovel = createTexture(c => drawPixels(c, shovelMap, {B:"#555", S:"#8d6e63"}));

// --- MATERIALS ---
const materials = [
  [ new THREE.MeshLambertMaterial({ map: tGrassSide.tex }), new THREE.MeshLambertMaterial({ map: tGrassSide.tex }), new THREE.MeshLambertMaterial({ map: tGrassTop.tex }), new THREE.MeshLambertMaterial({ map: tDirt.tex }), new THREE.MeshLambertMaterial({ map: tGrassSide.tex }), new THREE.MeshLambertMaterial({ map: tGrassSide.tex }) ],
  new THREE.MeshLambertMaterial({ map: tStone.tex }),
  new THREE.MeshLambertMaterial({ map: tWood.tex }),
  new THREE.MeshLambertMaterial({ map: tLeaves.tex }),
  new THREE.MeshLambertMaterial({ map: tBedrock.tex }),
  new THREE.MeshLambertMaterial({ map: tIron.tex }),
  new THREE.MeshLambertMaterial({ map: tDiamond.tex })
];

const BLOCK_HP = { 0: 2, 1: 3, 2: 3, 3: 1, 4: 99999, 5: 5, 6: 8 };

const INV_DATA = [
  { name: "Grass",   type: 0, blockId: 0, icon: tGrassSide.icon },
  { name: "Stone",   type: 0, blockId: 1, icon: tStone.icon },
  { name: "Wood",    type: 0, blockId: 2, icon: tWood.icon },
  { name: "Leaves",  type: 0, blockId: 3, icon: tLeaves.icon },
  { name: "Iron",    type: 0, blockId: 5, icon: tIron.icon },    
  { name: "Diamond", type: 0, blockId: 6, icon: tDiamond.icon }, 
  { name: "Pickaxe", type: 1, toolId: "pick", icon: tPickaxe.icon },
  { name: "Axe",     type: 1, toolId: "axe", icon: tAxe.icon },
  { name: "Shovel",  type: 1, toolId: "shovel", icon: tShovel.icon },
];

let inventoryCounts = [0, 0, 0, 0, 0, 0, 1, 1, 1]; 
let selectedSlot = 0;

const hotbarEl = document.getElementById("hotbar");
INV_DATA.forEach((item, i) => {
  const div = document.createElement("div");
  div.className = "slot";
  if(i===0) div.classList.add("selected");
  div.id = `slot-${i}`;
  div.innerHTML = `<span class="key-bind">${i+1}</span><img src="${item.icon}" class="slot-icon">${item.type === 0 ? `<span class="count">0</span>` : ''}`;
  hotbarEl.appendChild(div);
});

// --- GAME LOGIC ---
const keys = {};
let velocityY = 0;
let onGround = false;
let sprint = false;
let flying = false;
let yaw = 0; let pitch = 0;

const boxGeo = new THREE.BoxGeometry(1,1,1);
const activeBlocks = {}; 
let modifiedBlocks = {}; 
const droppedItems = [];

// --- PROCEDURAL GENERATION ---
function getTerrainHeight(x, z) {
  const h1 = Math.sin(x / 10) * 4;
  const h2 = Math.cos(z / 12) * 4;
  const h3 = Math.sin((x+z) / 20) * 2;
  return Math.floor(h1 + h2 + h3);
}

// Initialize player position safely
const startY = getTerrainHeight(0,0) + 5;
camera.position.set(0, startY, 0);

// --- CHUNK MANAGEMENT ---
function updateWorld() {
  const px = Math.floor(camera.position.x);
  const pz = Math.floor(camera.position.z);

  for (let key in activeBlocks) {
    activeBlocks[key].keep = false;
  }

  for (let x = px - RENDER_DISTANCE; x <= px + RENDER_DISTANCE; x++) {
    for (let z = pz - RENDER_DISTANCE; z <= pz + RENDER_DISTANCE; z++) {
      if (Math.abs(x) > WORLD_BORDER || Math.abs(z) > WORLD_BORDER) continue;

      const surfaceY = getTerrainHeight(x, z);

      for (let y = -16; y <= surfaceY + 5; y++) {
        const key = `${x},${y},${z}`;
        
        // Load modification
        if (modifiedBlocks.hasOwnProperty(key)) {
           if (modifiedBlocks[key] === null) continue;
           if (!activeBlocks[key]) spawnBlock(x, y, z, modifiedBlocks[key]);
           else activeBlocks[key].keep = true;
           continue;
        }

        // Procedural
        let type = -1;
        if (y === -16) type = 4; // Bedrock
        else if (y < surfaceY - 3) {
           type = 1;
           if (y < -10) {
             if (Math.random() < 0.005) type = 6;
             else if (Math.random() < 0.05) type = 5;
           } else {
             if (Math.random() < 0.05) type = 5;
           }
        } 
        else if (y < surfaceY) type = 1; 
        else if (y === surfaceY) type = 0; 
        
        // Trees
        if (y > surfaceY) {
           const treeRng = Math.abs(Math.sin(x*123 + z*456));
           if (treeRng < 0.05 && x%3!==0 && z%3!==0) {
             const height = 4 + Math.floor(treeRng * 20) % 2;
             if (y <= surfaceY + height) type = 2; 
             else if (y <= surfaceY + height + 2) type = 3; 
           }
        }

        if (type !== -1) {
          if (!activeBlocks[key]) spawnBlock(x, y, z, type);
          else activeBlocks[key].keep = true;
        }
      }
    }
  }

  for (let key in activeBlocks) {
    if (!activeBlocks[key].keep) {
      scene.remove(activeBlocks[key]);
      delete activeBlocks[key];
    }
  }
}

function spawnBlock(x, y, z, type) {
  const mat = materials[type];
  const finalMat = Array.isArray(mat) ? mat.map(m=>m.clone()) : mat.clone();
  const mesh = new THREE.Mesh(boxGeo, finalMat);
  mesh.position.set(x
