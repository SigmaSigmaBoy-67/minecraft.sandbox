<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minecraft Phase 14: Fixed</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; font-family: monospace; user-select: none; }
  
  #crosshair {
    position: fixed; top: 50%; left: 50%;
    width: 10px; height: 10px;
    margin-left: -5px; margin-top: -5px;
    border: 2px solid white; 
    pointer-events: none; z-index: 10;
  }

  #ui-container {
    position: fixed; bottom: 20px; left: 50%;
    transform: translateX(-50%);
    text-align: center; pointer-events: none;
  }

  #hotbar {
    display: flex; gap: 4px; justify-content: center;
    background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;
    border: 2px solid #333; pointer-events: auto;
  }
  
  .slot {
    width: 44px; height: 44px; background: #8b8b8b; 
    border: 3px solid #373737;
    border-top: 3px solid #FFF; border-left: 3px solid #FFF;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .slot.selected { background: #bbb; border-color: white; }
  .slot-icon { width: 32px; height: 32px; image-rendering: pixelated; }

  #controls {
    position: fixed; top: 10px; left: 10px; color: white; 
    text-shadow: 1px 1px 0 #000; font-weight: bold;
  }
</style>
</head>
<body>

<div id="controls">WASD: Move | SPACE: Jump | HOLD CLICK: Mine | 1-4: Select Block</div>

<div id="game-ui">
  <div id="crosshair"></div>
  <div id="ui-container"><div id="hotbar"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --- SETTINGS ---
const RENDER_DISTANCE = 8; 
const SPEED = 0.11;
const JUMP = 0.22;
const GRAVITY = 0.015;

// --- SCENE ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 10, 45);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = "YXZ";

const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
dirLight.position.set(20, 50, 10);
scene.add(dirLight);

// --- TEXTURES ---
const canvas = document.createElement("canvas");
canvas.width = 16; canvas.height = 16;
const ctx = canvas.getContext("2d");

function createTexture(drawFn) {
    ctx.clearRect(0,0,16,16);
    drawFn(ctx);
    const dataUrl = canvas.toDataURL();
    const copy = document.createElement("canvas");
    copy.width=16; copy.height=16;
    copy.getContext("2d").drawImage(canvas,0,0);
    const tex = new THREE.CanvasTexture(copy);
    tex.magFilter = THREE.NearestFilter;
    tex.colorSpace = THREE.SRGBColorSpace;
    return { tex, icon: dataUrl };
}

function noise(ctx, colors) {
    for(let i=0; i<256; i++) {
        ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
        ctx.fillRect(i%16, Math.floor(i/16), 1, 1);
    }
}

// Textures
const tGrassTop = createTexture(c => noise(c, ["#4caf50", "#388e3c"]));
const tGrassSide = createTexture(c => { 
    noise(c, ["#795548", "#5d4037"]); 
    c.fillStyle = "#4caf50"; c.fillRect(0,0,16,4); 
});
const tDirt = createTexture(c => noise(c, ["#795548", "#5d4037"]));
const tStone = createTexture(c => noise(c, ["#9e9e9e", "#757575", "#616161"]));
const tWood = createTexture(c => { 
    noise(c, ["#5d4037", "#4e342e"]); 
    c.fillStyle="#3e2723"; c.fillRect(4,0,2,16); c.fillRect(10,0,2,16); 
});
const tLeaves = createTexture(c => noise(c, ["#2e7d32", "#1b5e20", "#4caf50"]));

// Materials
const materials = [
    [new THREE.MeshLambertMaterial({map:tGrassSide.tex}), new THREE.MeshLambertMaterial({map:tGrassSide.tex}), new THREE.MeshLambertMaterial({map:tGrassTop.tex}), new THREE.MeshLambertMaterial({map:tDirt.tex}), new THREE.MeshLambertMaterial({map:tGrassSide.tex}), new THREE.MeshLambertMaterial({map:tGrassSide.tex})], // 0: Grass
    new THREE.MeshLambertMaterial({map:tStone.tex}), // 1: Stone
    new THREE.MeshLambertMaterial({map:tWood.tex}), // 2: Wood
    new THREE.MeshLambertMaterial({map:tLeaves.tex}) // 3: Leaves
];

// --- WORLD ---
const blocks = {};
const boxGeo = new THREE.BoxGeometry(1,1,1);

function spawn(x, y, z, type) {
    const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
    if(blocks[key]) return;
    
    // Safety check for materials
    let mat = materials[type];
    if(Array.isArray(mat)) mat = mat.map(m => m.clone()); // Clone array mats
    else mat = mat.clone();

    const mesh = new THREE.Mesh(boxGeo, mat);
    mesh.position.set(x, y, z);
    mesh.userData = { type, key, hp: (type===1?40:15) }; // Stone harder than grass
    scene.add(mesh);
    blocks[key] = mesh;
}

function getHeight(x, z) {
    return Math.floor(Math.sin(x/12)*3 + Math.cos(z/12)*3);
}

function generateChunk(cx, cz) {
    for(let x=cx-RENDER_DISTANCE; x<cx+RENDER_DISTANCE; x++) {
        for(let z=cz-RENDER_DISTANCE; z<cz+RENDER_DISTANCE; z++) {
            const h = getHeight(x,z);
            // Only spawn if nothing exists at height
            const k = `${x},${h},${z}`;
            if(!blocks[k]) {
                spawn(x, h, z, 0);   // Surface
                spawn(x, h-1, z, 1); // Subsurface
                spawn(x, h-2, z, 1);
                
                // Trees
                if(Math.random() < 0.02) {
                    spawn(x, h+1, z, 2);
                    spawn(x, h+2, z, 2);
                    spawn(x, h+3, z, 3); // Leaves
                }
            }
        }
    }
}

// --- PHYSICS (AABB) ---
function getBlock(x, y, z) {
    return blocks[`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`];
}

function checkCollision(pos) {
    const r = 0.3; // Player radius
    const feet = pos.clone(); feet.y -= 1.6;
    const head = pos.clone();
    
    const offsets = [[r,r], [r,-r], [-r,r], [-r,-r]];
    for(let o of offsets) {
        if(getBlock(feet.x+o[0], feet.y, feet.z+o[1])) return true; // Feet
        if(getBlock(head.x+o[0], head.y, head.z+o[1])) return true; // Head
        if(getBlock(feet.x+o[0], feet.y+0.8, feet.z+o[1])) return true; // Waist
    }
    return false;
}

// --- GAME LOOP ---
const keys = {};
let yaw = 0, pitch = 0;
let velY = 0;
let selectedSlot = 0;

// Mining
let isMining = false;
let miningProgress = 0;
let miningTarget = null;
const ray = new THREE.Raycaster();

document.addEventListener("keydown", e => {
    keys[e.code] = true;
    if(e.key >= '1' && e.key <= '4') {
        selectedSlot = parseInt(e.key)-1;
        updateHotbar();
    }
});
document.addEventListener("keyup", e => keys[e.code] = false);

document.body.onclick = () => document.body.requestPointerLock();
document.addEventListener("mousemove", e => {
    if(document.pointerLockElement) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
    }
});

document.addEventListener("mousedown", e => {
    if(document.pointerLockElement) {
        if(e.button === 0) isMining = true;
        if(e.button === 2) placeBlock();
    }
});
document.addEventListener("mouseup", () => {
    isMining = false; miningProgress = 0;
    if(miningTarget) {
        // Reset shake
        const [tx, ty, tz] = miningTarget.userData.key.split(',').map(Number);
        miningTarget.position.set(tx, ty, tz);
        miningTarget = null;
    }
});

// Start Game
camera.position.set(0, 8, 0);
generateChunk(0,0); // Initial gen
animate();

function animate() {
    requestAnimationFrame(animate);

    // Look
    camera.rotation.set(pitch, yaw, 0);

    // Move
    const move = new THREE.Vector3();
    if(keys["KeyW"]) move.z -= 1; if(keys["KeyS"]) move.z += 1;
    if(keys["KeyA"]) move.x -= 1; if(keys["KeyD"]) move.x += 1;
    move.applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize().multiplyScalar(SPEED);

    // Collision X
    if(!checkCollision(new THREE.Vector3(camera.position.x + move.x, camera.position.y, camera.position.z))) 
        camera.position.x += move.x;
    // Collision Z
    if(!checkCollision(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z + move.z))) 
        camera.position.z += move.z;

    // Gravity
    velY -= GRAVITY;
    const nextY = camera.position.y + velY;
    if(checkCollision(new THREE.Vector3(camera.position.x, nextY, camera.position.z))) {
        if(velY < 0 && keys["Space"]) velY = JUMP; // Jump if on ground
        else velY = 0;
    } else {
        camera.position.y += velY;
    }
    
    if(camera.position.y < -20) camera.position.set(0, 15, 0); // Void reset

    // Mining Logic
    if(isMining) {
        ray.setFromCamera(new THREE.Vector2(), camera);
        const hits = ray.intersectObjects(Object.values(blocks));
        if(hits.length > 0 && hits[0].distance < 4.5) {
            miningTarget = hits[0].object;
            miningProgress++;
            // Shake
            miningTarget.position.x += (Math.random()-0.5)*0.05;
            
            if(miningProgress > miningTarget.userData.hp) {
                scene.remove(miningTarget);
                delete blocks[miningTarget.userData.key];
                miningTarget = null;
                miningProgress = 0;
            }
        }
    }

    // Dynamic World (Simple)
    if(Math.random() < 0.05) {
        generateChunk(Math.floor(camera.position.x), Math.floor(camera.position.z));
    }
    
    renderer.render(scene, camera);
}

function placeBlock() {
    ray.setFromCamera(new THREE.Vector2(), camera);
    const hits = ray.intersectObjects(Object.values(blocks));
    if(hits.length > 0 && hits[0].distance < 4.5) {
        const p = hits[0].point.add(hits[0].face.normal.multiplyScalar(0.5)).floor();
        // Check player collision before placing
        if(p.distanceTo(camera.position) > 1.2) {
             spawn(p.x, p.y, p.z, selectedSlot);
        }
    }
}

// UI Setup
const hot = document.getElementById("hotbar");
const itemIcons = [tGrassSide.icon, tStone.icon, tWood.icon, tLeaves.icon];
itemIcons.forEach((icon, i) => {
    hot.innerHTML += `<div class="slot ${i===0?'selected':''}" onclick="selectedSlot=${i}; updateHotbar()"><img src="${icon}" class="slot-icon"></div>`;
});

function updateHotbar() {
    document.querySelectorAll(".slot").forEach((el, i) => {
        el.className = `slot ${i===selectedSlot?'selected':''}`;
    });
}

// Resize
window.onresize = () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
